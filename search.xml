<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java数组集合技巧合集</title>
      <link href="/2022/09/05/Java%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/"/>
      <url>/2022/09/05/Java%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p><strong>Arrays</strong></p><ul><li>Arrays 工具类中封装了大量的排序算法, 对于升序排序, 直接使用 Arrays.sort 即可.</li><li>如果想对数组类进行逆序排序&#x2F;自定义comparator排序<ul><li>包装类<ul><li><code>Arrays.sort(array, Arrays.sort(nums, (a,b)-&gt;&#123;return b-a;&#125;);)</code></li></ul></li><li>基本类型<ul><li><code>int[] sorted = Arrays.stream(nums).boxed().sorted((a,b)-&gt;&#123;return b-a;&#125;).mapToInt(a-&gt;a).toArray();</code></li></ul></li></ul></li></ul><h2 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h2><p><strong>基本类型数组-&gt;包装类数组</strong></p><ul><li><code>Integer[] sorted = Arrays.stream(nums).boxed().toArray(Integer[]::new);</code></li></ul><p><strong>基本类型数组-&gt;包装类集合</strong></p><ul><li><code>List&lt;Integer&gt; array = Arrays.stream(nums).boxed().collect(Collectors.toList());</code></li></ul><h2 id="集合排序"><a href="#集合排序" class="headerlink" title="集合排序"></a>集合排序</h2><p><strong>Collections</strong></p><ul><li><code>Collections.sort(array, (a,b)-&gt;&#123;return b-a;&#125;);</code></li></ul><h2 id="集合转换"><a href="#集合转换" class="headerlink" title="集合转换"></a>集合转换</h2><p><strong>包装类集合-&gt;包装类数组</strong></p><ul><li><code>Integer[] nums = array.stream().toArray(Integer[]::new);</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组双指针</title>
      <link href="/2022/09/02/%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2022/09/02/%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><strong>排序</strong></p><ul><li>使数组成为有序数组</li></ul><p><strong>左右指针</strong></p><ul><li>左右指针分别指向数组第一个元素和数组最后一个元素<ul><li><code>num[left]+num[right]&gt;target:right--;</code></li><li><code>num[left]+num[right]&lt;target:left++;</code></li></ul></li></ul><pre><code class="java">public int[] twoSum(int[] numbers, int target) &#123;    int left = 0;    int right = numbers.length - 1;    while (left &lt; right) &#123;      int p = numbers[left] + numbers[right];      if (p == target) &#123;        return new int[]&#123;left+1, right+1&#125;;      &#125; else if (p &gt; target) &#123;        right--;      &#125; else &#123;        left++;      &#125;    &#125;    return null;&#125;</code></pre><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p><strong>two sum 改造</strong></p><ul><li>增加一个搜索范围, lo, hi</li><li>成功找到一组后, lo 从下一个不同的地方开始</li></ul><pre><code class="java">public List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int lo, int hi, int target) &#123;    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    int left = lo;    int right = hi;    while (left &lt; right) &#123;        int nleft = nums[left];        int nright = nums[right];        int p = nleft + nright;        if (p == target) &#123;            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(Arrays.asList(nleft, nright, nums[lo-1]));            result.add(tmp);            while (nums[left] == nleft &amp;&amp; left &lt; right) &#123;              left++;            &#125;        &#125; else if (p &gt; target) &#123;            right--;        &#125; else &#123;            left++;        &#125;    &#125;    return result;&#125;</code></pre><p><strong>总体思路</strong></p><ul><li><p>对数组排序</p></li><li><p>外层循环遍历数组, i&#x3D;[0, length-3]</p></li><li><p><code>twoSum(numbers, i+1, length-1, target-nums[i])</code></p><ul><li>如果返回值为 null, 外层继续遍历</li><li>如果返回值不为 null, 加入结果集, 继续遍历</li></ul></li></ul><pre><code class="java">public List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int lo, int hi, int target) &#123;    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    int left = lo;    int right = hi;    while (left &lt; right) &#123;        int nleft = nums[left];        int nright = nums[right];        int p = nleft + nright;        if (p == target) &#123;            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(Arrays.asList(nleft, nright, nums[lo-1]));            result.add(tmp);            while (nums[left] == nleft &amp;&amp; left &lt; right) &#123;              left++;            &#125;        &#125; else if (p &gt; target) &#123;            right--;        &#125; else &#123;            left++;        &#125;    &#125;    return result;&#125;public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    Arrays.sort(nums);    for (int i = 0; i &lt; nums.length-2; i++) &#123;        int num = nums[i];        List&lt;List&lt;Integer&gt;&gt; twoSumResult = twoSum(nums, i+1, nums.length-1, 0-num);        if (!twoSumResult.isEmpty()) &#123;            result.addAll(twoSumResult);            while (i+1 &lt; nums.length-2 &amp;&amp; num == nums[i+1]) &#123;              i++;            &#125;        &#125;    &#125;    return result;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表双指针</title>
      <link href="/2022/08/10/%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2022/08/10/%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="链表成环"><a href="#链表成环" class="headerlink" title="链表成环"></a>链表成环</h2><h3 id="判断链表成环"><a href="#判断链表成环" class="headerlink" title="判断链表成环"></a>判断链表成环</h3><p><strong>dummy 头节点</strong></p><ul><li>使用 <strong>dummy</strong> 头节点避免空指针</li></ul><p><strong>快慢指针</strong></p><ul><li>快指针走两步, 慢指针走一步, 如果快指针走到末尾节点仍未和慢指针相遇, 则链表无反, 反之, 有环</li></ul><pre><code class="java">public boolean hasCycle(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next了;.next;      slow = slow.next;      if (fast == slow) &#123;        return true;      &#125;    &#125;    return false;&#125;</code></pre><h2 id="找到链表中点"><a href="#找到链表中点" class="headerlink" title="找到链表中点"></a>找到链表中点</h2><p>典型快慢指针, 判断链表成环类似</p><p><strong>dummy 头节点</strong></p><ul><li>使用 <strong>dummy</strong> 头节点避免空指针</li></ul><p><strong>快慢指针(终止条件)</strong></p><ul><li>if fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null, 快指针走两步, 慢指针走一步, if fast.next &#x3D;&#x3D; null: return slow;</li></ul><blockquote><p>长度为奇数</p><p>1-&gt;2(slow)-&gt;3-&gt;null(fast)</p><p>长度为偶数</p><p>1-&gt;2(slow)-&gt;3-&gt;4(fast)-&gt;null</p></blockquote><p><strong>举一反三</strong></p><ul><li>上述终止条件对应偶数长度时, 返回的是靠前的中间节点, 如何返回靠后的?<ul><li><code>return fast != null ? slow.next ? slow;</code></li></ul></li></ul><pre><code class="java">public ListNode middleNode(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next.next;      slow = slow.next;    &#125;    return fast != null ? slow.next : slow;&#125;</code></pre><h3 id="返回环的起点"><a href="#返回环的起点" class="headerlink" title="返回环的起点"></a>返回环的起点</h3><p><img src="./image-20220903201209897.png"></p><p>思路: 快慢指针相遇之后, 将慢指针重新指向头节点, 两个指针步长一致, 再次相遇时正好指向环的起点.</p><pre><code class="java">public ListNode detectCycle(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next.next;      slow = slow.next;      if (fast == slow) &#123;        slow = dummy;        int index = -1;        while (fast != null &amp;&amp; fast != slow) &#123;          fast = fast.next;          slow = slow.next;        &#125;        return slow;      &#125;    &#125;    return null;&#125;</code></pre><h2 id="删除倒数第-k-个节点"><a href="#删除倒数第-k-个节点" class="headerlink" title="删除倒数第 k 个节点"></a>删除倒数第 k 个节点</h2><p><strong>删除节点</strong></p><ul><li>例如如下链表 1-&gt;2-&gt;3, 我们如果要删除节点 2, 那么就需要用指针指向节点 2 的上一个节点, 执行 p.next &#x3D; p.next.next 即可.</li></ul><p><strong>dummy节点</strong></p><blockquote><p>dummy-&gt;head-&gt;…</p></blockquote><ul><li>如果我们要删除头节点, 那么我们指针如何指向头节点的上一个节点, 所以需要一个 dummy 节点</li></ul><p><strong>快慢指针</strong></p><blockquote><p>为了定位倒数 k+1 个节点</p><p>dummy-&gt;1-&gt;2-&gt;3(slow)-&gt;4-&gt;5-&gt;6-&gt;null(fast)</p></blockquote><p>当 slow 和 fast 之间始终间隔 k 个节点时, 如果 fast 节点遍历到 null, 那么 slow 节点正好指向倒数第 k+1 个节点</p><pre><code class="java"> public ListNode removeNthFromEnd(ListNode head, int n) &#123;     ListNode dummy = new ListNode();     dummy.next = head;     ListNode fast = head;     ListNode slow = dummy;     // 与 slow 间隔 k 个节点     for (int i = 0; i &lt; n; i++) &#123;       fast = fast.next;     &#125;     while (fast != null) &#123;       slow = slow.next;       fast = fast.next;     &#125;     slow.next = slow.next.next;     return dummy.next; &#125;</code></pre><h2 id="两链表相交节点"><a href="#两链表相交节点" class="headerlink" title="两链表相交节点"></a>两链表相交节点</h2><p>原始两条链表如下</p><p>a1-&gt;a2-&gt;b1-&gt;b2</p><p>c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3</p><p>将链表1和链表2拼接起来, 形成两条长度一样的链表, 可以发现在遍历完之前 b1 节点重合了</p><p>a1-&gt;a2-&gt;b1-&gt;b2-&gt;null-&gt;c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3-&gt;null</p><p>c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3-&gt;null-&gt;a1-&gt;a2-&gt;b1-&gt;b2-&gt;null</p><p>解题的关键是将链表1和链表2拼接起来, 判断的条件是如果在到达最后的 null 节点之前重合了, 那么节点相交</p><pre><code class="java">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;    ListNode p1 = headA;    ListNode p2 = headB;    while (p1 != p2) &#123;      if (p1 == null) &#123;        p1 = headB;      &#125; else &#123;        p1 = p1.next;      &#125;      if (p2 == null) &#123;        p2 = headA;      &#125; else &#123;        p2 = p2.next;      &#125;    &#125;    return p1;&#125;</code></pre><h2 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h2><h3 id="合并两个链表"><a href="#合并两个链表" class="headerlink" title="合并两个链表"></a>合并两个链表</h3><p><strong>dummy 节点</strong></p><ul><li>使用 dummy 节点保存新链表头指针的引用</li></ul><pre><code class="java">public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;    ListNode p1 = list1;    ListNode p2 = list2;    ListNode dummy = new ListNode();    ListNode p = dummy;    while (p1 != null &amp;&amp; p2 != null) &#123;      if (p1.val &gt; p2.val) &#123;        p.next = p2;        p2 = p2.next;      &#125; else &#123;        p.next = p1;        p1 = p1.next;      &#125;      p = p.next;    &#125;    if (p1 != null) &#123;      p.next = p1;    &#125;    if (p2 != null) &#123;      p.next = p2;    &#125;    return dummy.next;&#125;</code></pre><h3 id="合并-k-个链表"><a href="#合并-k-个链表" class="headerlink" title="合并 k 个链表"></a>合并 k 个链表</h3><p><strong>优先级队列</strong></p><ul><li>使用 PriorityQueue 保存不同链表的头节点, 每次从里面取出一个 val 最小的添加到新链表中</li></ul><pre><code class="java">PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((ListNode ln1, ListNode ln2)-&gt;&#123;return ln1.val - ln2.val;&#125;);</code></pre><pre><code class="java">public ListNode mergeKLists(ListNode[] lists) &#123;    PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((ListNode ln1, ListNode ln2)-&gt;&#123;return ln1.val - ln2.val;&#125;);    ListNode dummy = new ListNode();    ListNode p = dummy;    for (ListNode ln: lists) &#123;      if (ln != null) &#123;        pq.offer(ln);      &#125;    &#125;    while (!pq.isEmpty()) &#123;      ListNode n1 = pq.poll();      p.next = n1;      p = p.next;      if (n1.next != null) &#123;        pq.offer(n1.next);      &#125;    &#125;    return dummy.next;&#125;</code></pre><h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h2><p><strong>链表拆分, 注意切断原有联系</strong></p><blockquote><p>原链表: 1-&gt;5-&gt;3-&gt;4-&gt;6</p><p>新链表(smaller): 1-&gt;3-&gt;4(-&gt;6)</p><p>注意节点 4 后面还连着节点 6, 必须把其置为 null.</p></blockquote><pre><code class="java">public ListNode partition(ListNode head, int x) &#123;    ListNode smaller = new ListNode();    ListNode bigger = new ListNode();    ListNode p1 = smaller;    ListNode p2 = bigger;    ListNode p = head;    while (p != null) &#123;      if (p.val &lt; x) &#123;        p1.next = p;        p = p.next;        p1 = p1.next;      &#125; else &#123;        p2.next = p;        p = p.next;        p2 = p2.next;      &#125;    &#125;    // 切断原有联系    p2.next = null;    p1.next = bigger.next;    return smaller.next;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
