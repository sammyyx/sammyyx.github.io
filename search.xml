<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试</title>
      <link href="/2022/09/05/%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/09/05/%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>测试目录</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表双指针</title>
      <link href="/2022/08/10/%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%882/"/>
      <url>/2022/08/10/%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%882/</url>
      
        <content type="html"><![CDATA[<h2 id="链表成环"><a href="#链表成环" class="headerlink" title="链表成环"></a>链表成环</h2><h3 id="判断链表成环"><a href="#判断链表成环" class="headerlink" title="判断链表成环"></a>判断链表成环</h3><p><strong>dummy 头节点</strong></p><ul><li>使用 <strong>dummy</strong> 头节点避免空指针</li></ul><p><strong>快慢指针</strong></p><ul><li>快指针走两步, 慢指针走一步, 如果快指针走到末尾节点仍未和慢指针相遇, 则链表无反, 反之, 有环</li></ul><pre><code class="java">public boolean hasCycle(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next了;.next;      slow = slow.next;      if (fast == slow) &#123;        return true;      &#125;    &#125;    return false;&#125;</code></pre><h2 id="找到链表中点"><a href="#找到链表中点" class="headerlink" title="找到链表中点"></a>找到链表中点</h2><p>典型快慢指针, 判断链表成环类似</p><p><strong>dummy 头节点</strong></p><ul><li>使用 <strong>dummy</strong> 头节点避免空指针</li></ul><p><strong>快慢指针(终止条件)</strong></p><ul><li>if fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null, 快指针走两步, 慢指针走一步, if fast.next &#x3D;&#x3D; null: return slow;</li></ul><blockquote><p>长度为奇数</p><p>1-&gt;2(slow)-&gt;3-&gt;null(fast)</p><p>长度为偶数</p><p>1-&gt;2(slow)-&gt;3-&gt;4(fast)-&gt;null</p></blockquote><p><strong>举一反三</strong></p><ul><li>上述终止条件对应偶数长度时, 返回的是靠前的中间节点, 如何返回靠后的?<ul><li><code>return fast != null ? slow.next ? slow;</code></li></ul></li></ul><pre><code class="java">public ListNode middleNode(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next.next;      slow = slow.next;    &#125;    return fast != null ? slow.next : slow;&#125;</code></pre><h3 id="返回环的起点"><a href="#返回环的起点" class="headerlink" title="返回环的起点"></a>返回环的起点</h3><p><img src="/image-20220903201209897.png" alt="image-20220903201209897"></p><p>思路: 快慢指针相遇之后, 将慢指针重新指向头节点, 两个指针步长一致, 再次相遇时正好指向环的起点.</p><pre><code class="java">public ListNode detectCycle(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next.next;      slow = slow.next;      if (fast == slow) &#123;        slow = dummy;        int index = -1;        while (fast != null &amp;&amp; fast != slow) &#123;          fast = fast.next;          slow = slow.next;        &#125;        return slow;      &#125;    &#125;    return null;&#125;</code></pre><h2 id="删除倒数第-k-个节点"><a href="#删除倒数第-k-个节点" class="headerlink" title="删除倒数第 k 个节点"></a>删除倒数第 k 个节点</h2><p><strong>删除节点</strong></p><ul><li>例如如下链表 1-&gt;2-&gt;3, 我们如果要删除节点 2, 那么就需要用指针指向节点 2 的上一个节点, 执行 p.next &#x3D; p.next.next 即可.</li></ul><p><strong>dummy节点</strong></p><blockquote><p>dummy-&gt;head-&gt;…</p></blockquote><ul><li>如果我们要删除头节点, 那么我们指针如何指向头节点的上一个节点, 所以需要一个 dummy 节点</li></ul><p><strong>快慢指针</strong></p><blockquote><p>为了定位倒数 k+1 个节点</p><p>dummy-&gt;1-&gt;2-&gt;3(slow)-&gt;4-&gt;5-&gt;6-&gt;null(fast)</p></blockquote><p>当 slow 和 fast 之间始终间隔 k 个节点时, 如果 fast 节点遍历到 null, 那么 slow 节点正好指向倒数第 k+1 个节点</p><pre><code class="java"> public ListNode removeNthFromEnd(ListNode head, int n) &#123;     ListNode dummy = new ListNode();     dummy.next = head;     ListNode fast = head;     ListNode slow = dummy;     // 与 slow 间隔 k 个节点     for (int i = 0; i &lt; n; i++) &#123;       fast = fast.next;     &#125;     while (fast != null) &#123;       slow = slow.next;       fast = fast.next;     &#125;     slow.next = slow.next.next;     return dummy.next; &#125;</code></pre><h2 id="两链表相交节点"><a href="#两链表相交节点" class="headerlink" title="两链表相交节点"></a>两链表相交节点</h2><p>原始两条链表如下</p><p>a1-&gt;a2-&gt;b1-&gt;b2</p><p>c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3</p><p>将链表1和链表2拼接起来, 形成两条长度一样的链表, 可以发现在遍历完之前 b1 节点重合了</p><p>a1-&gt;a2-&gt;b1-&gt;b2-&gt;null-&gt;c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3-&gt;null</p><p>c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3-&gt;null-&gt;a1-&gt;a2-&gt;b1-&gt;b2-&gt;null</p><p>解题的关键是将链表1和链表2拼接起来, 判断的条件是如果在到达最后的 null 节点之前重合了, 那么节点相交</p><pre><code class="java">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;    ListNode p1 = headA;    ListNode p2 = headB;    while (p1 != p2) &#123;      if (p1 == null) &#123;        p1 = headB;      &#125; else &#123;        p1 = p1.next;      &#125;      if (p2 == null) &#123;        p2 = headA;      &#125; else &#123;        p2 = p2.next;      &#125;    &#125;    return p1;&#125;</code></pre><h2 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h2><h3 id="合并两个链表"><a href="#合并两个链表" class="headerlink" title="合并两个链表"></a>合并两个链表</h3><p><strong>dummy 节点</strong></p><ul><li>使用 dummy 节点保存新链表头指针的引用</li></ul><pre><code class="java">public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;    ListNode p1 = list1;    ListNode p2 = list2;    ListNode dummy = new ListNode();    ListNode p = dummy;    while (p1 != null &amp;&amp; p2 != null) &#123;      if (p1.val &gt; p2.val) &#123;        p.next = p2;        p2 = p2.next;      &#125; else &#123;        p.next = p1;        p1 = p1.next;      &#125;      p = p.next;    &#125;    if (p1 != null) &#123;      p.next = p1;    &#125;    if (p2 != null) &#123;      p.next = p2;    &#125;    return dummy.next;&#125;</code></pre><h3 id="合并-k-个链表"><a href="#合并-k-个链表" class="headerlink" title="合并 k 个链表"></a>合并 k 个链表</h3><p><strong>优先级队列</strong></p><ul><li>使用 PriorityQueue 保存不同链表的头节点, 每次从里面取出一个 val 最小的添加到新链表中</li></ul><pre><code class="java">PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((ListNode ln1, ListNode ln2)-&gt;&#123;return ln1.val - ln2.val;&#125;);</code></pre><pre><code class="java">public ListNode mergeKLists(ListNode[] lists) &#123;    PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((ListNode ln1, ListNode ln2)-&gt;&#123;return ln1.val - ln2.val;&#125;);    ListNode dummy = new ListNode();    ListNode p = dummy;    for (ListNode ln: lists) &#123;      if (ln != null) &#123;        pq.offer(ln);      &#125;    &#125;    while (!pq.isEmpty()) &#123;      ListNode n1 = pq.poll();      p.next = n1;      p = p.next;      if (n1.next != null) &#123;        pq.offer(n1.next);      &#125;    &#125;    return dummy.next;&#125;</code></pre><h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h2><p><strong>链表拆分, 注意切断原有联系</strong></p><blockquote><p>原链表: 1-&gt;5-&gt;3-&gt;4-&gt;6</p><p>新链表(smaller): 1-&gt;3-&gt;4(-&gt;6)</p><p>注意节点 4 后面还连着节点 6, 必须把其置为 null.</p></blockquote><pre><code class="java">public ListNode partition(ListNode head, int x) &#123;    ListNode smaller = new ListNode();    ListNode bigger = new ListNode();    ListNode p1 = smaller;    ListNode p2 = bigger;    ListNode p = head;    while (p != null) &#123;      if (p.val &lt; x) &#123;        p1.next = p;        p = p.next;        p1 = p1.next;      &#125; else &#123;        p2.next = p;        p = p.next;        p2 = p2.next;      &#125;    &#125;    // 切断原有联系    p2.next = null;    p1.next = bigger.next;    return smaller.next;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表双指针</title>
      <link href="/2022/08/10/%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2022/08/10/%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="链表成环"><a href="#链表成环" class="headerlink" title="链表成环"></a>链表成环</h2><h3 id="判断链表成环"><a href="#判断链表成环" class="headerlink" title="判断链表成环"></a>判断链表成环</h3><p><strong>dummy 头节点</strong></p><ul><li>使用 <strong>dummy</strong> 头节点避免空指针</li></ul><p><strong>快慢指针</strong></p><ul><li>快指针走两步, 慢指针走一步, 如果快指针走到末尾节点仍未和慢指针相遇, 则链表无反, 反之, 有环</li></ul><pre><code class="java">public boolean hasCycle(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next了;.next;      slow = slow.next;      if (fast == slow) &#123;        return true;      &#125;    &#125;    return false;&#125;</code></pre><h2 id="找到链表中点"><a href="#找到链表中点" class="headerlink" title="找到链表中点"></a>找到链表中点</h2><p>典型快慢指针, 判断链表成环类似</p><p><strong>dummy 头节点</strong></p><ul><li>使用 <strong>dummy</strong> 头节点避免空指针</li></ul><p><strong>快慢指针(终止条件)</strong></p><ul><li>if fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null, 快指针走两步, 慢指针走一步, if fast.next &#x3D;&#x3D; null: return slow;</li></ul><blockquote><p>长度为奇数</p><p>1-&gt;2(slow)-&gt;3-&gt;null(fast)</p><p>长度为偶数</p><p>1-&gt;2(slow)-&gt;3-&gt;4(fast)-&gt;null</p></blockquote><p><strong>举一反三</strong></p><ul><li>上述终止条件对应偶数长度时, 返回的是靠前的中间节点, 如何返回靠后的?<ul><li><code>return fast != null ? slow.next ? slow;</code></li></ul></li></ul><pre><code class="java">public ListNode middleNode(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next.next;      slow = slow.next;    &#125;    return fast != null ? slow.next : slow;&#125;</code></pre><h3 id="返回环的起点"><a href="#返回环的起点" class="headerlink" title="返回环的起点"></a>返回环的起点</h3><p><img src="./image-20220903201209897.png"></p><p>思路: 快慢指针相遇之后, 将慢指针重新指向头节点, 两个指针步长一致, 再次相遇时正好指向环的起点.</p><pre><code class="java">public ListNode detectCycle(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next.next;      slow = slow.next;      if (fast == slow) &#123;        slow = dummy;        int index = -1;        while (fast != null &amp;&amp; fast != slow) &#123;          fast = fast.next;          slow = slow.next;        &#125;        return slow;      &#125;    &#125;    return null;&#125;</code></pre><h2 id="删除倒数第-k-个节点"><a href="#删除倒数第-k-个节点" class="headerlink" title="删除倒数第 k 个节点"></a>删除倒数第 k 个节点</h2><p><strong>删除节点</strong></p><ul><li>例如如下链表 1-&gt;2-&gt;3, 我们如果要删除节点 2, 那么就需要用指针指向节点 2 的上一个节点, 执行 p.next &#x3D; p.next.next 即可.</li></ul><p><strong>dummy节点</strong></p><blockquote><p>dummy-&gt;head-&gt;…</p></blockquote><ul><li>如果我们要删除头节点, 那么我们指针如何指向头节点的上一个节点, 所以需要一个 dummy 节点</li></ul><p><strong>快慢指针</strong></p><blockquote><p>为了定位倒数 k+1 个节点</p><p>dummy-&gt;1-&gt;2-&gt;3(slow)-&gt;4-&gt;5-&gt;6-&gt;null(fast)</p></blockquote><p>当 slow 和 fast 之间始终间隔 k 个节点时, 如果 fast 节点遍历到 null, 那么 slow 节点正好指向倒数第 k+1 个节点</p><pre><code class="java"> public ListNode removeNthFromEnd(ListNode head, int n) &#123;     ListNode dummy = new ListNode();     dummy.next = head;     ListNode fast = head;     ListNode slow = dummy;     // 与 slow 间隔 k 个节点     for (int i = 0; i &lt; n; i++) &#123;       fast = fast.next;     &#125;     while (fast != null) &#123;       slow = slow.next;       fast = fast.next;     &#125;     slow.next = slow.next.next;     return dummy.next; &#125;</code></pre><h2 id="两链表相交节点"><a href="#两链表相交节点" class="headerlink" title="两链表相交节点"></a>两链表相交节点</h2><p>原始两条链表如下</p><p>a1-&gt;a2-&gt;b1-&gt;b2</p><p>c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3</p><p>将链表1和链表2拼接起来, 形成两条长度一样的链表, 可以发现在遍历完之前 b1 节点重合了</p><p>a1-&gt;a2-&gt;b1-&gt;b2-&gt;null-&gt;c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3-&gt;null</p><p>c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3-&gt;null-&gt;a1-&gt;a2-&gt;b1-&gt;b2-&gt;null</p><p>解题的关键是将链表1和链表2拼接起来, 判断的条件是如果在到达最后的 null 节点之前重合了, 那么节点相交</p><pre><code class="java">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;    ListNode p1 = headA;    ListNode p2 = headB;    while (p1 != p2) &#123;      if (p1 == null) &#123;        p1 = headB;      &#125; else &#123;        p1 = p1.next;      &#125;      if (p2 == null) &#123;        p2 = headA;      &#125; else &#123;        p2 = p2.next;      &#125;    &#125;    return p1;&#125;</code></pre><h2 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h2><h3 id="合并两个链表"><a href="#合并两个链表" class="headerlink" title="合并两个链表"></a>合并两个链表</h3><p><strong>dummy 节点</strong></p><ul><li>使用 dummy 节点保存新链表头指针的引用</li></ul><pre><code class="java">public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;    ListNode p1 = list1;    ListNode p2 = list2;    ListNode dummy = new ListNode();    ListNode p = dummy;    while (p1 != null &amp;&amp; p2 != null) &#123;      if (p1.val &gt; p2.val) &#123;        p.next = p2;        p2 = p2.next;      &#125; else &#123;        p.next = p1;        p1 = p1.next;      &#125;      p = p.next;    &#125;    if (p1 != null) &#123;      p.next = p1;    &#125;    if (p2 != null) &#123;      p.next = p2;    &#125;    return dummy.next;&#125;</code></pre><h3 id="合并-k-个链表"><a href="#合并-k-个链表" class="headerlink" title="合并 k 个链表"></a>合并 k 个链表</h3><p><strong>优先级队列</strong></p><ul><li>使用 PriorityQueue 保存不同链表的头节点, 每次从里面取出一个 val 最小的添加到新链表中</li></ul><pre><code class="java">PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((ListNode ln1, ListNode ln2)-&gt;&#123;return ln1.val - ln2.val;&#125;);</code></pre><pre><code class="java">public ListNode mergeKLists(ListNode[] lists) &#123;    PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((ListNode ln1, ListNode ln2)-&gt;&#123;return ln1.val - ln2.val;&#125;);    ListNode dummy = new ListNode();    ListNode p = dummy;    for (ListNode ln: lists) &#123;      if (ln != null) &#123;        pq.offer(ln);      &#125;    &#125;    while (!pq.isEmpty()) &#123;      ListNode n1 = pq.poll();      p.next = n1;      p = p.next;      if (n1.next != null) &#123;        pq.offer(n1.next);      &#125;    &#125;    return dummy.next;&#125;</code></pre><h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h2><p><strong>链表拆分, 注意切断原有联系</strong></p><blockquote><p>原链表: 1-&gt;5-&gt;3-&gt;4-&gt;6</p><p>新链表(smaller): 1-&gt;3-&gt;4(-&gt;6)</p><p>注意节点 4 后面还连着节点 6, 必须把其置为 null.</p></blockquote><pre><code class="java">public ListNode partition(ListNode head, int x) &#123;    ListNode smaller = new ListNode();    ListNode bigger = new ListNode();    ListNode p1 = smaller;    ListNode p2 = bigger;    ListNode p = head;    while (p != null) &#123;      if (p.val &lt; x) &#123;        p1.next = p;        p = p.next;        p1 = p1.next;      &#125; else &#123;        p2.next = p;        p = p.next;        p2 = p2.next;      &#125;    &#125;    // 切断原有联系    p2.next = null;    p1.next = bigger.next;    return smaller.next;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
