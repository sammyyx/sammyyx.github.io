<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络相关计算题</title>
      <link href="/2022/09/15/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97%E9%A2%98/"/>
      <url>/2022/09/15/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E8%AE%A1%E7%AE%97%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="A类、B类、C类地址ip范围"><a href="#A类、B类、C类地址ip范围" class="headerlink" title="A类、B类、C类地址ip范围"></a>A类、B类、C类地址ip范围</h2><h3 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h3><p>最高位由 0 开头, 1字节的网络地址和3字节的主机地址构成(掩码: 255.0.0.0)</p><p>00000000,00000000,00000000,00000000 ~ 01111111,11111111,11111111,11111111</p><p>所以地址范围为: 0.0.0.0 ~ 127.255.255.255</p><p>由于 0 和 127 不能作为主机的 ip 地址, 所以 A 类地址最多有 126 个网络.</p><h3 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h3><p>最高位由 10 开头, 2字节的网络地址和2字节的主机地址构成(掩码: 255.255.0.0)</p><p>10000000,00000000,00000000,00000000 ~ 10111111,11111111,11111111,11111111</p><p>地址范围: 128.0.0.0 ~ 191.255.255.255</p><p>可用网络个数 2^14 - 1 &#x3D; 16383</p><p>每个网段可用地址个数 2^16-2</p><h3 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h3><p>最高位由 110 开头, 3字节的网络地址和1字节的主机地址构成(掩码: 255.255.0.0)</p><h3 id="D类地址"><a href="#D类地址" class="headerlink" title="D类地址"></a>D类地址</h3><p>最高位由 1110 开头</p><h3 id="E类地址"><a href="#E类地址" class="headerlink" title="E类地址"></a>E类地址</h3><p>最高位由 11110 开头</p>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法-数学类</title>
      <link href="/2022/09/15/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6%E7%B1%BB/"/>
      <url>/2022/09/15/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-%E6%95%B0%E5%AD%A6%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="素-质-数、偶数、奇数"><a href="#素-质-数、偶数、奇数" class="headerlink" title="素(质)数、偶数、奇数"></a>素(质)数、偶数、奇数</h1><p><strong>素数</strong>: 只能被 1 和它本身整除</p><pre><code class="java">public void printPrime(int start, int end) &#123;    for (int i = start; i &lt;= end; i++) &#123;        int j = 0;        for (j = 2; j &lt;= Math.sqrt(i); j++) &#123;            if (i % j == 0) &#123;              break;            &#125;        &#125;        if (j &gt; Math.sqrt(i)) &#123;            System.out.println(i);        &#125;    &#125;&#125;</code></pre><p><strong>偶数</strong>: 能被 2 整除</p><p><strong>奇数</strong>: 不能被 2 整除</p><h1 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h1><pre><code class="java">if (c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;) &#123;  char c1 = (char)(c-32);  return c1;&#125; else if (c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;) &#123;  char c1 = (char)(c+32);  return c2;&#125;</code></pre><p>字符串排序,大写排前面,小写排后面</p>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 八股文合集</title>
      <link href="/2022/09/12/Java-%E5%85%AB%E8%82%A1%E6%96%87%E5%90%88%E9%9B%86/"/>
      <url>/2022/09/12/Java-%E5%85%AB%E8%82%A1%E6%96%87%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h2><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p><strong>强一致性、弱一致性、最终一致性</strong></p><p>强一致性: 要求更新过的数据能被后序的访问看到</p><p>弱一致性: 容忍更新过的数据存在部分访问不到</p><p>最终一致性: 要求经过一段时间后, 更新过的数据能被访问到</p><h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象?"></a>什么是面向对象?</h3><p>面向对象关注于完成一件事情需要哪些步骤,步骤之间的执行顺序.</p><p>面向对象关注于完成一件事情需要哪些模块参与, 模块与模块之间的关系.</p><p>面向对象的三大特征: 封装、继承、多态</p><p>封装: 对象的属性不对外暴露, 暴露操作属性的方法.</p><p>继承: 子类继承父类, 对父类进行功能扩展.</p><p>多态: 基于对象所属类的不同, 外部对同一个方法的调用, 实际执行的逻辑不同.</p><h3 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a>重写和重载的区别</h3><p><strong>重载</strong>: 发生在同一个类中, 方法名必须相同, 参数类型不同, 个数不同, 顺序不同, 方法返回值和访问修饰符可以不同, 发生在编译时</p><p><strong>重写</strong>: 发生在父子类中,方法名、参数列表必须相同, 返回值范围小于等于父类(返回值类型必须为父类返回值的派生类), 抛出异常范围小于等于父类, 访问修饰符大于等于父类; private 方法不能重写.</p><h3 id="concurrentHashMap"><a href="#concurrentHashMap" class="headerlink" title="concurrentHashMap"></a>concurrentHashMap</h3><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><p>关键字: 两次 hash</p><p><strong>一次找到 segment 数组下标, 一次找到 segment 中的链表头</strong></p><p>segment 可以理解为 Hash 表头指针数组</p><p><strong>jdk 1.7</strong></p><p><img src="./hashMap.drawio.png"></p><p>按 segment 来加锁, 避免锁冲突.</p><p>扩容: 按照 segment 来扩容, 复制到新数组, 然后头指针指向新数组.</p><p><strong>jdk 1.8</strong></p><p>关键字: 使用 node 节点代替 segment 数组</p><p>插入时, 先判断头节点是否为空, 如果为空, 则用 cas 去设置头节点. 如果不为空, 则用 synchronized 锁住头节点, 判断头节点是否相同, 然后执行链表或二叉树的插入操作</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p><strong>jdk 1.7</strong></p><p>数组+链表</p><p>链表解决哈希冲突</p><p>链表插入是头插法</p><p>复杂的散列算法 - 尽可能地减少哈希冲突</p><p><strong>插入过程</strong></p><ol><li>根据 key 通过哈希算法得出数组下标</li><li>如果数组下标位置为空, 封装 Entry 对象, 放在当前位置</li><li>如果数组下标位置不为空, 则判断是否需要扩容, 不扩容就生成 Entry 对象, 使用头插法插入元素<ol><li>插入需要遍历链表看 key 是否存在, 存在即更新value</li></ol></li></ol><p><strong>jdk 1.8</strong></p><p>数组+链表+红黑树</p><p>红黑树: 提高插入和查询效率</p><p>链表插入是尾插法</p><blockquote><p>因为 1.8 中插入 key 和 value 时需要判断链表元素个数</p></blockquote><p>使用简单的散列算法代替 jdk1.7 中复杂的散列算法, 因为红黑树查询效率很高</p><p><strong>插入过程</strong></p><ol><li>根据 key 通过哈希算法得出数组下标</li><li>如果数组下标位置为空, 封装 Entry 对象, 放在当前位置</li><li>如果数组下标位置不为空, 判断数组当前位置的 Node 是链表还是红黑树类型<ol><li>如果是红黑树, 添加到红黑树里面. 如果红黑树为包含当前 key, 则更新 value</li><li>如果为链表, 则使用尾插法, 插入, 同样需要遍历链表看是否有相同 key, 最后在链表尾部插入, 同时判断长度是否 &gt;&#x3D; 8, 如果是, 则转换为红黑树</li><li>最后判断是否需要扩容, 如果不需要就结束 PUT, 需要就参与扩容</li></ol></li></ol><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p><strong>jdk 1.7</strong></p><ol><li>先生成新数组</li><li>遍历老数组中的每个位置上的链表上的每个元素</li><li>取每个元素的key, 并基于新数组长度, 计算出元素在新数组中的下标</li><li>将元素添加到新数组中</li><li>所有元素转移完后, 将新数组复制 HashMap 的 table 属性</li></ol><p><strong>jdk 1.8</strong></p><ol><li>先生成新数组</li><li>遍历老数组中的每个位置上的链表或红黑树上的每个元素</li><li>如果是链表, 重新计算下标, 放到新数组中</li><li>如果是红黑树, 先遍历红黑树, 计算出红黑树中每个元素对应在新数组中的下标位置<ol><li>统计每个下标位置的元素个数</li><li>如果元素个数超过了 8 , 生成一个新的红黑树, 将根节点添加到数组对应位置</li><li>如果元素个数小于 8, 生成一个链表, 并将链表头节点添加到数组对应位置</li></ol></li><li>所有元素转移完后, 将新数组复制 HashMap 的 table 属性</li></ol><h4 id="HashMap-中的-loadFactor"><a href="#HashMap-中的-loadFactor" class="headerlink" title="HashMap 中的 loadFactor"></a>HashMap 中的 loadFactor</h4><p>HashMap扩容机制: 当 map 中的容量大于一个阈值时, 触发 hashMap 的扩容</p><p><code>阈值=factor*capacity</code></p><p><strong>为什么要扩容</strong></p><p>为了查询效率的原因, 当容量太小时, 发生 hash 冲突的概率会增大, 按照 hashMap 的底层结构来看, 散列到同一个数组下标的查询效率为变为 o(n)&#x2F;o(logn), 所以扩容本质是用空间来换取时间的一种方法.</p><p><strong>为什么需要阈值?</strong></p><p>如果我们每次都等 HashMap 容量到达上限之后再扩容, 那么此时hash冲突的概率会上升, 查找效率会变慢, 提前扩容可以某种程度上提前规避 hash 冲突.</p><p><strong>loadFactor 值的设置</strong></p><p>loadFactor 值越大, 空间利用率变高, 但是因为hash冲突可能导致查询效率的降低</p><p>loadFactor 值越小, 空间利用率变低, 但是可以提前规避hash冲突使查询效率提升</p><p>所以本质上 loadFactor 的取值是一个权衡</p><p><strong>loadFactor 为什么默认是 0.75</strong></p><ol><li><p>根据hashMap的扩容机制, 他会保证 capacity 的值永远是 2 的幂次方,  0.75 * 任何 2 的幂次都是整数.</p></li><li><p>根据数学推导, capacity 的值在log(2)左右时是比较合理的.</p></li></ol><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝: 拷贝基本数据类型的值以及实例对象的引用地址</p><p>深拷贝: 拷贝基本数据类型的值和实例对象引用地址所指向的对象进行复制</p><p>一句话: 拷贝出来的实例, 其对象类型的成员变量是不是同一个.</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p>类装载子系统、字节码执行引擎、JVM运行时数据区</p><p><strong>字节码文件反编译</strong> <code>javap</code></p><p>JVM运行时数据区包含 堆、栈、本地方法栈、元空间、程序计数器</p><h4 id="JVM-运行时数据区"><a href="#JVM-运行时数据区" class="headerlink" title="JVM 运行时数据区"></a>JVM 运行时数据区</h4><p>栈: 局部变量、操作数栈、动态链接、方法出口</p><blockquote><p>操作数: 比如 1 +  2 这个加法操作, 1 和 2 就是操作数, 运算之后的结果 3 也是一个操作数</p></blockquote><p>程序计数器: 存储马上要运行的代码的位置(内存地址)</p><blockquote><p>为什么需要程序计数器? 比如当前线程被其他线程打断挂起, 线程恢复之后需要从挂起的位置继续执行, 需要需要程序计数器去记录这个位置</p><p>程序计数器是谁设置的呢? 字节码执行引擎根据方法区当中存储的类信息执行引擎动态修改的.</p></blockquote><p>动态链接: 将符号引用转为直接引用</p><blockquote><p>符号: 变量名、方法名</p><p>举个例子: 将方法名转为指向方法区对应方法存储的内存地址</p></blockquote><p>方法出口: 指向调用完当前方法的返回地址</p><h4 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h4><p>谁去执行 GC 操作?</p><blockquote><p>字节码执行引擎会在后台开一个垃圾收集线程</p></blockquote><p>JVM 可视化工具: jvisualvm</p><p>Arthas: JVM 调优工具</p><p>JVM 调优目的: 减少 STW 的时间</p><p>对象大小怎么评估?</p><blockquote><p>所有成员变量占用空间之和</p></blockquote><p>能否对 JVM 调优, 让其几乎不发生 FGC</p><blockquote><p>目的, 尽量让垃圾对象在 YGC 的时候就 GC 掉, 不要晋升到老年代</p></blockquote><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p>引导类加载器: 加载 JRE lib 目录下的核心类</p><p>扩展类加载器: 负责 JRE lib 目录下的 ext 扩展类</p><p>应用程序类加载器: 负责加载 classPath 路径下的类包</p><p>自定义加载器: 加载用户自定义路径下的类包</p><h4 id="类加载双亲委派机制"><a href="#类加载双亲委派机制" class="headerlink" title="类加载双亲委派机制"></a>类加载双亲委派机制</h4><p>一句话: 子类加载器首先向上委托父类加载器加载, 父类加载器无法加载再由子类加载器加载</p><p>自顶向下分别时是</p><ul><li>引导类加载器</li><li>扩展类加载器</li><li>应用程序类加载器</li><li>自定义加载器</li></ul><p><strong>为什么?</strong></p><p>安全性, 保证核心类库的安全</p><p>唯一性, 避免类重复加载</p><blockquote><p>tomcat 当中的类加载有所不同, 为了保证不同 war 包的一个隔离性, 不同 war 是由不同类加载器加载, 且第三方依赖的不同版本可以共存</p></blockquote><h4 id="对象完整创建流程"><a href="#对象完整创建流程" class="headerlink" title="对象完整创建流程"></a>对象完整创建流程</h4><ol><li>类加载检查</li><li>判断是否加载<ol><li>否,加载类</li></ol></li><li>分配内存</li><li>初始化零值</li><li>设置对象头 64位(锁,分代年龄)</li><li>执行 init 方法<ol><li>为对象赋值</li><li>执行构造方法</li></ol></li></ol><h4 id="指针碰撞和空闲列表"><a href="#指针碰撞和空闲列表" class="headerlink" title="指针碰撞和空闲列表"></a>指针碰撞和空闲列表</h4><p>指针碰撞: 如果 Java 堆中内存是绝对规整, 空闲内存在一边, 用过的内存在另一边, 通过记录这个边界的位置, 分配对象可以直接从指针出分配</p><p>空闲列表: Java 堆分配不规整, 对还没被使用的空闲空间用列表记录, 分配对象时从空闲列表中找到合适的空间进行分配</p><h4 id="分配空间时并发问题解决"><a href="#分配空间时并发问题解决" class="headerlink" title="分配空间时并发问题解决"></a>分配空间时并发问题解决</h4><p>CAS+分配重试: CAS 比较边界指针的值</p><p>本地线程分配缓冲(TLAB): 每个线程在 Java 堆中预先分配一小块内存, 优先在本线程内空间分配</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis-底层存储结构"><a href="#Redis-底层存储结构" class="headerlink" title="Redis 底层存储结构"></a>Redis 底层存储结构</h3><p>一句话: 哈希表+跳表</p><p><strong>好处</strong>: 既支持范围搜索也支持精确搜索</p><p><strong>什么是跳表?</strong></p><blockquote><p>跳表是在链表的基础上改进过来的, 实现了一种多层的有序链表</p></blockquote><p>下图展示了一个层级为 3 的跳表, 图中头节点有 L0 - L2 三个头指针, 每个层级的节点都通过头指针链接起来, 跳表的查询复杂度是 O(logN)</p><p><img src="./2355823-20220427153753717-1118740554.png" alt="2355823-20220427153753717-1118740554"></p><h3 id="redis-删除实现"><a href="#redis-删除实现" class="headerlink" title="redis 删除实现"></a>redis 删除实现</h3><p><strong>惰性删除</strong>: 当读&#x2F;写一个已经过期的 key 时, 会触发惰性删除, 判断 key 是否已经过期</p><p><strong>定时删除</strong>: 定期(默认100sms)主动淘汰一批已经过期的 key</p><p>耗时: 删除大对象或对集合类型的key做删除都会很慢</p><h3 id="集群架构转变"><a href="#集群架构转变" class="headerlink" title="集群架构转变"></a>集群架构转变</h3><p>主从架构</p><p>哨兵架构</p><p>集群架构</p><ul><li>数据 hash 分片算法</li></ul><h4 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h4><p><img src="./v2-8c5c7cf74726539165651580692c33c5_1440w.jpeg" alt="v2-8c5c7cf74726539165651580692c33c5_1440w"></p><p>CAP 理论规定只能实现 CP 和 AP.</p><p>C: 总是能读到最新写入的数据</p><p>A: 非故障节点在合理的时间内返回合理的回复</p><p>P: 当出现网路分区后, 系统能够继续提供服务 </p><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><h3 id="远程调用的步骤"><a href="#远程调用的步骤" class="headerlink" title="远程调用的步骤"></a>远程调用的步骤</h3><p>客户端调用远程方法-&gt;封装远程调用请求-&gt;发送远程调用-&gt;服务端接收远程调用-&gt;服务端解析远程调用参数-&gt;调用本地方法-&gt;封装远程调用结果-&gt;发送远程调用结果-&gt;客户端接收远程调用结果-&gt;远程调用结果解析为本地调用结果返回</p><p><strong>RPC 框架的目的</strong>: 让远程调用像本地调用一样方便</p><p><strong>核心实现</strong>: 动态代理(封装底层网络细节)+网络通信(寻址、序列化和反序列化、网络协议)</p><h3 id="寻址-注册中心"><a href="#寻址-注册中心" class="headerlink" title="寻址(注册中心)"></a>寻址(注册中心)</h3><p>核心实现: Map -&gt; key为服务名, Value 为可用的 ip 地址列表</p><p><strong>分布式Map -&gt; redis</strong></p><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>底层可用 http&#x2F;tcp&#x2F;protobuf 等协议</p><p>如何让框架通过动态的方式直接协议的绑定?</p><blockquote><p>解析用户配置-&gt;根据用户配置进行协议绑定</p></blockquote><h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><p><strong>Java 原生 SPI</strong></p><blockquote><p> 在系统设计中, 模块间都是不指定具体的借口实现类的, 一旦代码里指定了实现类就无法在不修改代码的情况下替换另一种实现.</p></blockquote><p>Java 提供了, 接口+实现类(第三方)+配置文件的方式实现动态加载机制.</p><pre><code class="java">ServiceLoader&lt;Animal&gt; serviceLoader = ServiceLoader.load(Animal.class);for (Animal animal: serviceLoader) &#123;  animal.call();&#125;</code></pre><p><strong>不足之处</strong></p><ol><li>不能直接指定加载某一个类, 只能遍历配置文件中的所有类来找到我们想要的类</li><li>获取类的方式不够灵活</li><li>ServiceLoader 线程不安全</li></ol><h4 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h4><ol><li>通过 Key 获取我们想要的对象实例, 支持注解默认实现</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 八股文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC 和 Spring Boot 的区别</title>
      <link href="/2022/09/10/Spring-MVC-%E5%92%8C-Spring-Boot-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/09/10/Spring-MVC-%E5%92%8C-Spring-Boot-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-框架-amp-Spring-MVC-amp-Spring-Boot"><a href="#Spring-框架-amp-Spring-MVC-amp-Spring-Boot" class="headerlink" title="Spring 框架 &amp; Spring MVC &amp; Spring Boot"></a>Spring 框架 &amp; Spring MVC &amp; Spring Boot</h2><h3 id="Spring-框架"><a href="#Spring-框架" class="headerlink" title="Spring 框架"></a>Spring 框架</h3><p>Spring 框架包含很多模块, 其中比较重要的是 Spring-Core (IoC容器)模块、Spring 中其他模块(AOP&#x2F;ORM&#x2F;Web)的功能实现基本都需要依赖该模块.</p><p>Spring MVC 是 Spring 中的一个很重要的模块, 主要赋予 Spring 快速构建 MVC 架构的 Web 程序. 使用 Spring 进行开发各种配置过于麻烦, 比如开启 Spring 的某些特性时, 需要用 XML 或 Java 进行显示配置, 于是 Spring Boot 诞生了.</p><p>Spring Boot 提供了一种快速使用 Spring 套件的能力, 提供可插拔的设计, 就是各种 starter.</p><p><strong>总结</strong></p><ul><li>Spring: 引擎, 核心是 IOC 和 AOP</li><li>Spring MVC: 是基于 Spring 核心的一个模块</li><li>Spring Boot: 基于 Spring 的快速开发工具包</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GC算法总结</title>
      <link href="/2022/09/09/GC%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/09/09/GC%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="判断对象是否可以回收"><a href="#判断对象是否可以回收" class="headerlink" title="判断对象是否可以回收"></a>判断对象是否可以回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>每个对象会有一个引用计数器, 记录这个对象被引用的次数. 当引用次数为 0 时, 代表这个对象可以被 GC 回收.</p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul><li>无法处理循环引用的情况.</li><li>堆内对象每一次引用赋值和引用清楚, 都会伴随着加减法的操作, 会带来一定的性能开销.</li></ul><p><strong>循环引用问题</strong></p><pre><code>class A &#123;    private B b;    public void setB(B b) &#123;        this.b = b;    &#125;&#125;class B &#123;    private A a = new A();    public void setA(A a) &#123;        this.a = a;    &#125;&#125;public void method() &#123;    A a = new A();    B b = new B();    a.setB(b);    b.setA(a);&#125;</code></pre><p><img src="./%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.drawio.png"></p><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>可达性分析法定义了 <code>GC Roots</code> 对象作为起始点, 从这个起点开始向下搜索, 每一条可达路径被称为引用链, 当一个对象没有人意一条引用链可以到达 <code>GC Roots</code> 时, 那么就对这个对象进行第一次可回收标记.</p><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>堆外指向堆内的引用, 下面这些对象可以作为 GC Roots</p><ul><li>代码中某一方法的局部变量</li><li>类静态变量</li><li>常量</li><li>本地方法栈中引用的对象</li><li>已启动且未停止的线程</li></ul><p>以下面代码为例</p><pre><code class="java">class Test &#123;    private static A a = new A(); // 静态变量    public static final String CONTANT = &quot;I am a string&quot;; // 常量    public static void main(String[] args) &#123;        A innerA = new A(); // 局部变量    &#125;&#125;class A &#123;    ...&#125;</code></pre><p><img src="./%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0-2.drawio.png" alt="循环引用计数-第 2 页.drawio"></p><p>此时 GC Roots 状态为</p><p><img src="./%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0-3.drawio.png"></p><p>当 main 方法执行完毕时, 栈帧出栈, 此时 GC Roots 状态为</p><p><img src="./%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0-4.drawio.png" alt="循环引用计数-第 4 页.drawio"></p><p>此时 A2 被打上标记</p><p>当 GC 判定某一对象不再通过任一形式被引用时, GC 会调用该对象的 finalize 方法, 且一个对象只会执行一次 finalize 方法. 方法被执行时, 可以进行任何操作, 包括将这个对象再次赋值给某一变量引用</p><p><strong>自救</strong>: 在 finalize 方法中, 将这个对象的引用再次赋值给某一变量</p><h3 id="不同引用类型的回收"><a href="#不同引用类型的回收" class="headerlink" title="不同引用类型的回收"></a>不同引用类型的回收</h3><h4 id="2-1-强引用"><a href="#2-1-强引用" class="headerlink" title="2.1 强引用"></a>2.1 强引用</h4><p>通过关键字new的对象就是强引用对象，强引用指向的对象任何时候都不会被回收，宁愿OOM也不会回收。</p><h4 id="2-2-软引用"><a href="#2-2-软引用" class="headerlink" title="2.2 软引用"></a>2.2 软引用</h4><p>如果一个对象持有软引用，那么当JVM堆空间不足时，会被回收。</p><p>一个类的软引用可以通过java.lang.ref.SoftReference持有。</p><h4 id="2-3-弱引用"><a href="#2-3-弱引用" class="headerlink" title="2.3 弱引用"></a>2.3 弱引用</h4><p>如果一个对象持有弱引用，那么在GC时，只要发现弱引用对象，就会被回收。</p><p>一个类的弱引用可以通过java.lang.ref.WeakReference持有。</p><h4 id="2-4-虚引用"><a href="#2-4-虚引用" class="headerlink" title="2.4 虚引用"></a>2.4 虚引用</h4><p>几乎和没有一样，随时可以被回收。</p><p>通过PhantomReference持有。</p><h3 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h3><p><strong>为什么会有 STW</strong>: 如果程序一边执行, 一边进行可达性分析的标记操作, 那么有可能刚标记完一个对象, 这个对象又被再次被赋值给其他的引用. 这样就有可能回收掉正在使用的对象. 解决方式就是使用 STW, STW 会在所有线程到达一个安全点时, 暂停掉所有应用线程的执行, 然后开始专心的标记垃圾对象.</p><p><strong>本质</strong>: 保证数据的一致性.</p><p><strong>安全点</strong>: 引用关系不会发生变化的点</p><h2 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h2><p>三个基础的 GC 算法: 标记-清除, 标记-整理, 复制算法</p><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><ul><li>标记阶段: 通过可达性分析将不可达的对象标记出来</li><li>清除阶段: 将标记阶段标记的垃圾对象清除</li></ul><p>缺点: 回收后会产生大量不连续的内存空间(碎片), 由于 Java 在分配内存时通常是按连续内存分配, 所以当碎片空间不足以分配给新对象时, 就会造成内存浪费</p><h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h3><ul><li>标记阶段: 通过可达性分析将不可达的对象标记出来</li><li>碎片整理: 将所有存活对象都向一边移动</li><li>清除阶段: 直接清理掉边界外的内存</li></ul><p>缺点: 碎片整理会有性能消耗</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将内存空间分为两块, 每次只使用其中一块内存. 当 GC 执行时, 会将非垃圾对象复制到另一块内存中, 保证内存连续性, 然后直接情况之前使用的内存.</p><p>缺点: 会损失一半的内存</p><h3 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h3><p>复制算法和标记整理算法都有各自适合的使用场景。</p><p>复制算法适用于每次回收时，存活对象少的场景，这样就会减少复制量。</p><p>标记整理算法适用于回收时，存活对象多的场景，这样就会减少内存碎片的产生，碎片整理的代价就会小很多。</p><p>分代算法将内存区域分为两部分：新生代和老年代。</p><p>根据新生代和老年代中对象的不同特点，使用不同的GC算法。</p><p>新生代对象的特点是：创建出来没多久就可以被回收（例如虚拟机栈中创建的对象，方法出栈就会销毁）。也就是说，每次回收时，大部分是垃圾对象，所以新生代适用于复制算法。</p><p>老年代的特点是：经过多次GC，依然存活。也就是说，每次GC时，大部分是存活对象，所以老年代适用于标记整理算法。</p><p><strong>新生代中的不可达对象不一定是垃圾</strong></p><p><img src="./%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0-5.drawio.png"></p><p>如上图所示, young 区的 A 对象没有被 GC Roots 引用, 但是却被 old 区对象引用.此时 A 对象不是垃圾. 不能被 GC 掉.</p><p><strong>如何解决?</strong></p><p>引入一个卡表解决. 卡表最简单的形式是一个字节数组.</p><p><code>CARD_TABLE[this address &gt;&gt; 9]=0</code></p><p>HotSpot 中使用的卡页是 2 的 9 次幂, 卡表的每一个元素就对应了容量为 512 字节的内存块. 只要卡页内有一个对象的字段存在跨代指针, 整个卡表的这个元素就会被标识为 1, 因此可以很轻易的判断出哪些内存块中包含跨代指针.</p><h2 id="GC-器"><a href="#GC-器" class="headerlink" title="GC 器"></a>GC 器</h2><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>CMS 全称 Concurrent Mark Sweep, 是一款并发的、使用标记-清除算法, 针对老年代的垃圾回收器, 其最大的特点就是让垃圾收集线程与用户线程同时工作.</p><p>CMS 收集器的过程</p><ol><li>初始标记, STW, 标记 GCRoots 直接关联的对象</li><li>并发标记, 没有 STW, 可以与用户线程并发运行</li><li>重新标记, STW, 修正并发标记期间用户程序继续运行导致的变动</li><li>并发清除, 不需要移动存活对象</li></ol><p><strong>缺点</strong></p><ul><li>浮动垃圾, 是由并发清理过程导致的, 由于没有 STW, 用户进程会有新垃圾产生<ul><li>-XX:CMSInitialOccupancyFraction</li></ul></li><li>内存碎片<ul><li>-XX:UseCMSCompactAtFullCollection 可以指定开启碎片整理</li><li>XX:CMSFullGCBeforeCompaction 或者是多少次 FGC 后启动碎片整理</li></ul></li><li>对 CPU 资源敏感</li></ul><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>整体来看, 是基于标记-整理算法实现的收集器</p><p>局部来看, region与region之间是使用的复制算法</p><p><strong>特点</strong></p><ul><li>属于分代型垃圾回收器, 但新生代和老年代步物理隔离, 不用担心每个代内存是否足够</li><li>将整个堆分为 2048 个大小相同的独立 Region 块</li><li>有一个巨型区, 但巨型对象超过分区容量一半时, 会存入巨型区</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划经典题-编辑距离</title>
      <link href="/2022/09/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E9%A2%98-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
      <url>/2022/09/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E9%A2%98-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/edit-distance">https://leetcode.cn/problems/edit-distance</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>dp数组定义</strong></p><p>有字符串 s1 和 s2, 求 s1 -&gt; s2 的最短距离</p><pre><code>dp[i][j] : s1[0,i] 和 s2[0,j] 的最短编辑距离</code></pre><p><strong>选择对 dp 数组的影响</strong></p><p>当 <code> s1[i] == s2[j]</code> 时, 此时选择跳过当前字符, <code>dp[i][j]=dp[i-1][j-1]</code></p><p>当 <code>s1[i] != s2[j]</code> 时, 此时有三种选择, 取三种选择中最小的一个即可,<code> Math.min(dp[i-1][j]+1,dp[i-1][j-1]+1,dp[i][j-1]+1)</code></p><ul><li>删除当前字符, 那么 <code>dp[i][j]=dp[i-1][j]+1</code></li><li>替换当前字符, 那么 <code>dp[i][j]=dp[i-1][j-1]+1</code></li><li>新增当前字符, 那么<code>dp[i][j]=dp[i][j-1]+1</code></li></ul><h3 id="自顶向下-递归解法"><a href="#自顶向下-递归解法" class="headerlink" title="自顶向下(递归解法)"></a>自顶向下(递归解法)</h3><pre><code class="java">public int minDistance(String word1, String word2) &#123;        int[][] memo = new int[word1.length()][word2.length()];        for (int i = 0; i &lt; word1.length(); i++) &#123;            for (int j = 0; j &lt; word2.length(); j++) &#123;                memo[i][j] = -1;            &#125;        &#125;        return dp(word1, word1.length()-1, word2,word2.length()-1, memo);    &#125;    public int dp(String word1, int i, String word2, int j, int[][] memo) &#123;        if (i == -1) return j+1;        if (j == -1) return i+1;        if (memo[i][j] != -1) return memo[i][j];        if (word1.charAt(i) == word2.charAt(j)) &#123;            memo[i][j] = dp(word1, i-1, word2, j-1, memo);        &#125; else &#123;            memo[i][j] = Math.min(Math.min(dp(word1, i-1, word2, j,memo)+1,dp(word1, i-1, word2, j-1,memo)+1),dp(word1, i, word2, j-1,memo)+1);        &#125;        return memo[i][j];    &#125;</code></pre><h3 id="自底向上-动态规划"><a href="#自底向上-动态规划" class="headerlink" title="自底向上(动态规划)"></a>自底向上(动态规划)</h3><pre><code>if s1[i] == s1[j]: dp[i][j]=dp[i-1][j-1]if s1[i] != s1[j]:     dp[i][j]=min(dp[i-1][j]+1,dp[i-1][j-1]+1,dp[i][j-1]+1)</code></pre><p>从上面的推导公式可以看出, 二维数组 <code>dp[i][j]</code> 这个格子只与其 斜左上, 上, 左 三个格子相关, 即: 只要知道这三个格子的值就能推导出  <code>dp[i][j]</code></p><pre><code class="java">public int minDistance(String word1, String word2) &#123;        int[][] dp = new int[word1.length()+1][word2.length()+1];        for (int i = 0; i &lt;= word1.length(); i++) &#123;            for (int j = 0; j &lt;= word2.length(); j++) &#123;                dp[i][j] = -1;            &#125;        &#125;        for (int i = 0; i &lt;= word1.length(); i++) &#123;            dp[i][0] = i;        &#125;        for (int i = 0; i &lt;= word2.length(); i++) &#123;            dp[0][i] = i;        &#125;        for (int i = 1; i &lt;= word1.length(); i++) &#123;            for (int j = 1; j &lt;= word2.length(); j++) &#123;                if (word1.charAt(i-1) == word2.charAt(j-1)) &#123;                    dp[i][j] = dp[i-1][j-1];                &#125; else &#123;                    dp[i][j] = Math.min(Math.min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1;                &#125;            &#125;        &#125;        return dp[word1.length()][word2.length()];    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列基本原理</title>
      <link href="/2022/09/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="消息中间件构成"><a href="#消息中间件构成" class="headerlink" title="消息中间件构成"></a>消息中间件构成</h2><p>一句话介绍: 与 RPC 类似是一种进程间通信的方式, 生产者通过 Broker 将消息存储在队列里, 消费者通过订阅关系取到对应消息.</p><p>使用 MQ 可以将调用过程异步、实现功能解耦、削峰填谷.</p><p>基本架构分为「生产者」、「消费者」和「Broker」</p><p><img src="./%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6.drawio.png"></p><h3 id="消息中间件的设计"><a href="#消息中间件的设计" class="headerlink" title="消息中间件的设计"></a>消息中间件的设计</h3><h4 id="推拉模式的设计"><a href="#推拉模式的设计" class="headerlink" title="推拉模式的设计"></a>推拉模式的设计</h4><p>推拉模式都是消费者主动去和 Broker 建立连接(轮询或长轮询), 然后将消息拉回消费端.</p><blockquote><p>长轮询: 客户端发起 polling 请求, 如果服务端没有相关数据, 会 hold 住请求, 直到服务端有相关数据, 或者等待超时才返回, 返回后客户端会发起下一次 polling 请求.</p><p>轮询: 客户端每隔定长时间请求一次数据, 可能有数据返回, 可能没有.</p><p>长轮询为什么需要超时时间: tcp 三次握手建立的连接会通过底层 keep alive 计时器保证, 但这个连接失活发现太慢了, 消费端不能依赖这个保活手段, 所以设计了超时时间.</p></blockquote><p>推拉模式在消息中间件中如何定义?</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-基础求和问题</title>
      <link href="/2022/09/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-…-100求和问题"><a href="#1-…-100求和问题" class="headerlink" title="1+…+100求和问题"></a>1+…+100求和问题</h2><h3 id="FutureTask-Callable"><a href="#FutureTask-Callable" class="headerlink" title="FutureTask+Callable"></a>FutureTask+Callable</h3><pre><code class="java">package com.samyyx.test;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * 1+...+n */public final class App &#123;    static class Adder implements Callable&lt;Long&gt; &#123;        private long start;        private long end;        public Adder(long start, long end) &#123;            this.start = start;            this.end = end;        &#125;        @Override        public Long call() throws Exception &#123;            System.out.println(Thread.currentThread().getId());            long sum = 0;            for (long i = start; i &lt;= end; i++) &#123;                sum += i;            &#125;            return sum;        &#125;    &#125;    public static void main(String[] args) &#123;        // 并发执行        FutureTask&lt;Long&gt; f1 = new FutureTask&lt;&gt;(new Adder(1, n / 2));        FutureTask&lt;Long&gt; f2 = new FutureTask&lt;&gt;(new Adder(n / 2 + 1, n));        Thread t1 = new Thread(f1);        Thread t2 = new Thread(f2);        t1.start();        t2.start();        try &#123;            long sum = f1.get() + f2.get();            System.out.println(&quot;parallel sum:&quot;+sum);            long cost = System.currentTimeMillis() - cur;            System.out.println(&quot;parallel cost:&quot; + cost);        &#125; catch (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125;          // 串行执行        cur = System.currentTimeMillis();        long sum = 0;        for (long i = 1; i &lt;= n; i++) &#123;            sum += i;        &#125;        System.out.println(&quot;serial sum:&quot;+sum);        long cost = System.currentTimeMillis() - cur;        System.out.println(&quot;serial cost:&quot; + cost);    &#125;&#125;</code></pre><h3 id="countDownLatch"><a href="#countDownLatch" class="headerlink" title="countDownLatch"></a>countDownLatch</h3><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法基本框架</title>
      <link href="/2022/09/06/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/"/>
      <url>/2022/09/06/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><pre><code class="java">private void traverse(...) &#123;    if (是否可以终止?) &#123;          // 结果保存        return;    &#125;    for (选择: 所有选择) &#123;        // 进行选择        traverse(...);        // 撤销选择    &#125;&#125;</code></pre><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p><strong>visited 数组</strong></p><ul><li>使用 visited 数组记录数组中元素的使用, 跳过使用过的元素</li></ul><pre><code class="java">List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();private void traverse(int[] nums, boolean[] visited, LinkedList&lt;Integer&gt; track) &#123;    if (track.size() == nums.length) &#123;        List&lt;Integer&gt; copy = new LinkedList&lt;&gt;(track);        result.add(copy);        return;    &#125;    for (int i = 0; i &lt; nums.length; i++) &#123;        if (visited[i]) continue;        track.add(nums[i]);        visited[i] = true;        traverse(nums, visited, track);        visited[i] = false;        track.removeLast();    &#125;&#125;public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;    boolean[] visited = new boolean[nums.length];    LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;();    traverse(nums, visited, track);    return result;&#125;</code></pre><h2 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h2><p><strong>判断是否可以放皇后</strong></p><ul><li>由于是逐行放皇后, 所以仅需考虑「与皇后同列」、「皇后左上」、「皇后右上」</li></ul><pre><code class="java">List&lt;List&lt;String&gt;&gt; result = new LinkedList&lt;&gt;();private void traverse(LinkedList&lt;String&gt; board, int curRow, int n) &#123;    if (board.size() == n) &#123;        result.add(new LinkedList&lt;&gt;(board));        return;    &#125;    for (int j = 0; j &lt; n; j++) &#123;        if (isValid(board, curRow, j, n)) &#123;            board.add(newBoard(n, j));            traverse(board, curRow + 1, n);            board.removeLast();        &#125;    &#125;&#125;private String newBoard(int n, int j) &#123;    String s = &quot;&quot;;    for (int i = 0; i &lt; n; i++) &#123;        if (i == j)            s += &quot;Q&quot;;        else            s += &quot;.&quot;;    &#125;    return s;&#125;private boolean isValid(List&lt;String&gt; board, int row, int column, int n) &#123;    // 同列    for (String s : board) &#123;        if (s.charAt(column) == &#39;Q&#39;)            return false;    &#125;    // 左上    for (int i = row - 1, j = column - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123;        if (board.get(i).charAt(j) == &#39;Q&#39;)            return false;    &#125;    // 右上    for (int i = row - 1, j = column + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123;        if (board.get(i).charAt(j) == &#39;Q&#39;)            return false;    &#125;    return true;&#125;public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;    LinkedList&lt;String&gt; board = new LinkedList&lt;&gt;();    traverse(board, 0, n);    return result;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划基本框架</title>
      <link href="/2022/09/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/"/>
      <url>/2022/09/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>递推公式:</p><p><code>f(n)=f(n-1)+f(n-2)</code></p><p><code>f(0)=0,f(1)=1</code></p><pre><code class="java">public int fib(int n) &#123;    if (n == 0) &#123;        return 0;    &#125;    if (n == 1) &#123;        return 1;    &#125;    int[] dp = new int[n+1];    dp[0] = 0;    dp[1] = 1;    for (int i = 2; i &lt; n+1; i++) &#123;        dp[i] = dp[i-1] + dp[i-2];    &#125;    return dp[n];&#125;</code></pre><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><h3 id="自顶向下-递归"><a href="#自顶向下-递归" class="headerlink" title="自顶向下(递归)"></a>自顶向下(递归)</h3><p><strong>备忘录</strong></p><ul><li><p>使用 memo 数组保存已经递归出结果的值(剪枝)</p></li><li><p>memo 数组初始化</p><ul><li>最大值为 amount + 1(没有比面值为1的硬币更小的)</li></ul></li></ul><p><strong>无解判断</strong></p><ul><li>若遍历完所有可能后, memo 值还是最大值, 则置为 -1 表示无解</li></ul><pre><code class="java">private int traverse(int[] coins, int amount, int[] memo) &#123;    if (memo[amount] != amount + 1) &#123;        return memo[amount];    &#125;    for (int i = 0; i &lt; coins.length; i++) &#123;        if (amount - coins[i] &gt;= 0) &#123;            int num = traverse(coins, amount-coins[i], memo);            if (num == -1) continue;            if (memo[amount] &gt; num + 1) &#123;                memo[amount] = num + 1;            &#125;        &#125;    &#125;    if (memo[amount] == amount + 1) &#123;      memo[amount] = -1;    &#125;    return memo[amount];&#125;public int coinChange(int[] coins, int amount) &#123;    int[] memo = new int[amount+1];    for (int i = 0; i &lt; amount + 1; i++) &#123;        memo[i] = i+1;    &#125;    memo[0] =  0;    int result = traverse(coins, amount, memo);    return result;&#125;</code></pre><h3 id="自低向上-动态规划"><a href="#自低向上-动态规划" class="headerlink" title="自低向上(动态规划)"></a>自低向上(动态规划)</h3><p><code>f(coin)=1,coin in coins</code> </p><p><code>f(coin+f(n))=f(n)+1, coin in coins, f(n) != n+1</code> </p><p><strong>版本一</strong></p><pre><code class="java">public int coinChange(int[] coins, int amount) &#123;    boolean[] visited = new boolean[amount+1];    if (amount == 0) return 0;    int[] dp = new int[amount+1];    for (int i = 0; i &lt; amount + 1; i++) &#123;        dp[i] = i+1;    &#125;    Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();    for (int i = 0; i &lt; coins.length; i++) &#123;        if (coins[i] &lt;= amount) &#123;            dp[coins[i]] = 1;            q.offer(coins[i]);        &#125;    &#125;    while (!q.isEmpty()) &#123;        long cur = q.poll();        for (int i = 0; i &lt; coins.length; i++) &#123;            long coinL = coins[i];              // 部分case cur+coin 会超出 int 范围, 所以需要使用 long            long target = cur+coinL;            if (target &gt; amount) continue;            if (dp[(int)cur] + 1 &lt; dp[(int)target]) &#123;                dp[(int)target] = dp[(int)cur] + 1;                  // 剪枝                if (!visited[(int)target]) &#123;                    q.offer((int)target);                    visited[(int)target] = true;                &#125;            &#125;        &#125;    &#125;    return dp[amount] == amount + 1 ? -1 : dp[amount];&#125;</code></pre><p>可以看出这个版本缺点很明显, 需要额外的存储空间, 而且需要考虑 int 范围问题</p><p><strong>版本二</strong></p><p>调整下遍历逻辑, 外层循环从 1 遍历到 amount, 内层循环所有可能的选择.</p><pre><code class="java">public int coinChange(int[] coins, int amount) &#123;    int[] dp = new int[amount+1];    dp[0] = 0;    for (int i = 1; i &lt; amount + 1; i++) &#123;        dp[i] = i + 1;    &#125;    for (int i = 1; i &lt; amount + 1; i++) &#123;        for (int coin: coins) &#123;            if (i - coin &lt; 0) continue;            if (dp[i-coin] == i-coin+1) continue;            dp[i] = Math.min(dp[i-coin]+1, dp[i]);        &#125;    &#125;    return dp[amount] == amount + 1 ? -1 : dp[amount]; &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归二叉树</title>
      <link href="/2022/09/05/%E9%80%92%E5%BD%92%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/09/05/%E9%80%92%E5%BD%92%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前-x2F-中-x2F-后序遍历"><a href="#前-x2F-中-x2F-后序遍历" class="headerlink" title="前&#x2F;中&#x2F;后序遍历"></a>前&#x2F;中&#x2F;后序遍历</h2><p><strong>递归</strong></p><ul><li>只要是递归调用, 就存在前序和后序<ul><li>前序指递归前</li><li>后序指递归后</li></ul></li><li>由于二叉树需要先后递归左右子树, 在两次递归之间称为中序</li></ul><pre><code class="java">private List&lt;Integer&gt; track = new ArrayList&lt;&gt;();private void traverse(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    track.add(root.val);    traverse(root.left);      // 中序遍历 track.add(root.val);    traverse(root.right);      // 后序遍历 track.add(root.val);&#125;public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;    traverse(root);    return track;&#125;</code></pre><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p><strong>最大深度</strong>: 根节点到「最远」叶子节点的最长路径上的节点个数</p><p><strong>思路</strong>: 遍历所有「叶子节点」, 比较「根节点」到所有「叶子节点」的长度, 取最大的一个</p><pre><code class="java">private int maxDepth = 0;private void traverse(TreeNode root, int depth) &#123;    if (root == null) &#123;        return;    &#125;    if (root.left == null &amp;&amp; root.right == null) &#123;        maxDepth = Math.max(maxDepth, depth);    &#125;    traverse(root.left, depth+1);    traverse(root.right, depth+1);&#125;public int maxDepth(TreeNode root) &#123;    traverse(root, 1);    return maxDepth;&#125;</code></pre><h2 id="利用后序位置搜集子树的信息"><a href="#利用后序位置搜集子树的信息" class="headerlink" title="利用后序位置搜集子树的信息"></a>利用后序位置搜集子树的信息</h2><h3 id="统计二叉树节点个数"><a href="#统计二叉树节点个数" class="headerlink" title="统计二叉树节点个数"></a>统计二叉树节点个数</h3><p>由于后序是在递归之后发生, 可以理解后序是站在根节点观察左右子树, 在这个位置可以拿到左右子树的遍历结果.</p><p>当前根节点对应的子树包含的节点个数 &#x3D; 「左子树」的节点个数 + 「右子树」的节点个数 + 1「根节点」</p><pre><code class="java">private int count = 0;private int traverse(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    int left = traverse(root.left);    int right = traverse(root.right);    // 「左子树」的节点个数 + 「右子树」的节点个数 + 1「根节点」    count = Math.max(left+right+1, count);    return left+right+1;&#125;public int countNodeOfBinaryTree(TreeNode root) &#123;    traverse(root);    return count;&#125;</code></pre><h3 id="二叉树的最长直径"><a href="#二叉树的最长直径" class="headerlink" title="二叉树的最长直径"></a>二叉树的最长直径</h3><p>「当前子树的最长直径」&#x3D; 其「左子树」的深度 + 其「右子树」的深度</p><pre><code class="java">private int diameter = 0;private int traverse(TreeNode root) &#123;    if (root == null) &#123;          return 0;    &#125;    int left = traverse(root.left);    int right = traverse(root.right);      // 「左子树」的深度 + 其「右子树」的深度    diameter = Math.max(left+right, diameter);    return Math.max(left, right) + 1;&#125;public int diameterOfBinaryTree(TreeNode root) &#123;    traverse(root);    return diameter;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组集合技巧合集</title>
      <link href="/2022/09/05/Java%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/"/>
      <url>/2022/09/05/Java%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p><strong>Arrays</strong></p><ul><li>Arrays 工具类中封装了大量的排序算法, 对于升序排序, 直接使用 Arrays.sort 即可.</li><li>如果想对数组类进行逆序排序&#x2F;自定义comparator排序<ul><li>包装类<ul><li><code>Arrays.sort(array, Arrays.sort(nums, (a,b)-&gt;&#123;return b-a;&#125;);)</code></li></ul></li><li>基本类型<ul><li><code>int[] sorted = Arrays.stream(nums).boxed().sorted((a,b)-&gt;&#123;return b-a;&#125;).mapToInt(a-&gt;a).toArray();</code></li></ul></li></ul></li></ul><h2 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h2><p><strong>基本类型数组-&gt;包装类数组</strong></p><ul><li><code>Integer[] sorted = Arrays.stream(nums).boxed().toArray(Integer[]::new);</code></li></ul><p><strong>基本类型数组-&gt;包装类集合</strong></p><ul><li><code>List&lt;Integer&gt; array = Arrays.stream(nums).boxed().collect(Collectors.toList());</code></li></ul><h2 id="集合排序"><a href="#集合排序" class="headerlink" title="集合排序"></a>集合排序</h2><p><strong>Collections</strong></p><ul><li><code>Collections.sort(array, (a,b)-&gt;&#123;return b-a;&#125;);</code></li></ul><h2 id="集合转换"><a href="#集合转换" class="headerlink" title="集合转换"></a>集合转换</h2><p><strong>包装类集合-&gt;包装类数组</strong></p><ul><li><code>Integer[] nums = array.stream().toArray(Integer[]::new);</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组双指针</title>
      <link href="/2022/09/02/%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2022/09/02/%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><strong>排序</strong></p><ul><li>使数组成为有序数组</li></ul><p><strong>左右指针</strong></p><ul><li>左右指针分别指向数组第一个元素和数组最后一个元素<ul><li><code>num[left]+num[right]&gt;target:right--;</code></li><li><code>num[left]+num[right]&lt;target:left++;</code></li></ul></li></ul><pre><code class="java">public int[] twoSum(int[] numbers, int target) &#123;    int left = 0;    int right = numbers.length - 1;    while (left &lt; right) &#123;      int p = numbers[left] + numbers[right];      if (p == target) &#123;        return new int[]&#123;left+1, right+1&#125;;      &#125; else if (p &gt; target) &#123;        right--;      &#125; else &#123;        left++;      &#125;    &#125;    return null;&#125;</code></pre><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p><strong>two sum 改造</strong></p><ul><li>增加一个搜索范围, lo, hi</li><li>成功找到一组后, lo 从下一个不同的地方开始</li></ul><pre><code class="java">public List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int lo, int hi, int target) &#123;    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    int left = lo;    int right = hi;    while (left &lt; right) &#123;        int nleft = nums[left];        int nright = nums[right];        int p = nleft + nright;        if (p == target) &#123;            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(Arrays.asList(nleft, nright, nums[lo-1]));            result.add(tmp);            while (nums[left] == nleft &amp;&amp; left &lt; right) &#123;              left++;            &#125;        &#125; else if (p &gt; target) &#123;            right--;        &#125; else &#123;            left++;        &#125;    &#125;    return result;&#125;</code></pre><p><strong>总体思路</strong></p><ul><li><p>对数组排序</p></li><li><p>外层循环遍历数组, i&#x3D;[0, length-3]</p></li><li><p><code>twoSum(numbers, i+1, length-1, target-nums[i])</code></p><ul><li>如果返回值为 null, 外层继续遍历</li><li>如果返回值不为 null, 加入结果集, 继续遍历</li></ul></li></ul><pre><code class="java">public List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int lo, int hi, int target) &#123;    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    int left = lo;    int right = hi;    while (left &lt; right) &#123;        int nleft = nums[left];        int nright = nums[right];        int p = nleft + nright;        if (p == target) &#123;            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(Arrays.asList(nleft, nright, nums[lo-1]));            result.add(tmp);            while (nums[left] == nleft &amp;&amp; left &lt; right) &#123;              left++;            &#125;        &#125; else if (p &gt; target) &#123;            right--;        &#125; else &#123;            left++;        &#125;    &#125;    return result;&#125;public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    Arrays.sort(nums);    for (int i = 0; i &lt; nums.length-2; i++) &#123;        int num = nums[i];        List&lt;List&lt;Integer&gt;&gt; twoSumResult = twoSum(nums, i+1, nums.length-1, 0-num);        if (!twoSumResult.isEmpty()) &#123;            result.addAll(twoSumResult);            while (i+1 &lt; nums.length-2 &amp;&amp; num == nums[i+1]) &#123;              i++;            &#125;        &#125;    &#125;    return result;&#125;</code></pre><h2 id="原地操作数组"><a href="#原地操作数组" class="headerlink" title="原地操作数组"></a>原地操作数组</h2><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><ul><li>双指针, lo 指向待写入的下标, hi 指向写入值对应的下标</li></ul><pre><code class="java">public int removeElement(int[] nums, int val) &#123;    int lo = 0;    int hi = 0;    while (hi &lt; nums.length) &#123;      if (nums[hi] != val) &#123;        nums[lo] = nums[hi];        lo++;      &#125;      hi++;    &#125;    return lo;&#125;</code></pre><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h3><ul><li>移除值为 0 的元素, 然后将 <code>[lo,nums.length-1]</code> 都置为 0</li></ul><pre><code class="java">public void moveZeroes(int[] nums) &#123;    int lo = 0;    int hi = 0;    while (hi &lt; nums.length) &#123;      if (nums[hi] != 0) &#123;        nums[lo] = nums[hi];        lo++;      &#125;      hi++;    &#125;    for (int i = lo; i &lt; nums.length; i++) &#123;      nums[i] = 0;    &#125;&#125;</code></pre><h3 id="删除数组当中的重复项"><a href="#删除数组当中的重复项" class="headerlink" title="删除数组当中的重复项"></a>删除数组当中的重复项</h3><ul><li>数组是否为有序? <ul><li>无序先排序</li><li>有序, lo 指向待写入的下标(待写入的下标为被比较值下标+1), hi 指向待写入的值</li></ul></li></ul><pre><code class="java">public int removeDuplicates(int[] nums) &#123;    int lo = 0;    int hi = lo + 1;    while (hi &lt; nums.length) &#123;      // nums[lo]-&gt;被比较值      if (nums[hi] != nums[lo]) &#123;        // 指向待写入的下标        lo++;        nums[lo] = nums[hi];      &#125;      hi++;    &#125;    return lo+1;&#125;</code></pre><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><strong>回文子串的定义</strong></p><ul><li>回文子串有两种, 奇数长度 or 偶数长度<ul><li>奇数长度, 双指针从同一个中点像外扩散, 直到两个指针指向的值不相等</li><li>偶数长度, 双指针从相邻的中点像外扩散, 直到两个指针指向的值不相等</li></ul></li><li>由于最长回文子串的中点有可能是原始字符串中的任意一个元素, 所以外层需要遍历 s 的每一个字符</li></ul><p><strong>思路</strong>: 遍历原始字符串中每个元素, 尝试以当前元素(奇偶情况)作为回文子串的中点并向外扩散</p><pre><code class="java">private String longest(String s, int i, int j) &#123;    int len = s.length();    while (i &gt;= 0 &amp;&amp; j &lt; len &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;        i--;        j++;    &#125;    return s.substring(i+1, j);&#125;public String longestPalindrome(String s) &#123;    String max = &quot;&quot;;    for (int i = 0; i &lt; s.length(); i++) &#123;        String result1 = longest(s, i, i);        if (max.length() &lt; result1.length()) &#123;            max = result1;        &#125;        if (i+1 &lt; s.length()) &#123;            String result2 = longest(s, i, i+1);            if (max.length() &lt; result2.length()) &#123;                max = result2;            &#125;        &#125;    &#125;    return max;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表双指针</title>
      <link href="/2022/08/10/%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2022/08/10/%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="链表成环"><a href="#链表成环" class="headerlink" title="链表成环"></a>链表成环</h2><h3 id="判断链表成环"><a href="#判断链表成环" class="headerlink" title="判断链表成环"></a>判断链表成环</h3><p><strong>dummy 头节点</strong></p><ul><li>使用 <strong>dummy</strong> 头节点避免空指针</li></ul><p><strong>快慢指针</strong></p><ul><li>快指针走两步, 慢指针走一步, 如果快指针走到末尾节点仍未和慢指针相遇, 则链表无反, 反之, 有环</li></ul><pre><code class="java">public boolean hasCycle(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next了;.next;      slow = slow.next;      if (fast == slow) &#123;        return true;      &#125;    &#125;    return false;&#125;</code></pre><h2 id="找到链表中点"><a href="#找到链表中点" class="headerlink" title="找到链表中点"></a>找到链表中点</h2><p>典型快慢指针, 判断链表成环类似</p><p><strong>dummy 头节点</strong></p><ul><li>使用 <strong>dummy</strong> 头节点避免空指针</li></ul><p><strong>快慢指针(终止条件)</strong></p><ul><li>if fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null, 快指针走两步, 慢指针走一步, if fast.next &#x3D;&#x3D; null: return slow;</li></ul><blockquote><p>长度为奇数</p><p>1-&gt;2(slow)-&gt;3-&gt;null(fast)</p><p>长度为偶数</p><p>1-&gt;2(slow)-&gt;3-&gt;4(fast)-&gt;null</p></blockquote><p><strong>举一反三</strong></p><ul><li>上述终止条件对应偶数长度时, 返回的是靠前的中间节点, 如何返回靠后的?<ul><li><code>return fast != null ? slow.next ? slow;</code></li></ul></li></ul><pre><code class="java">public ListNode middleNode(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next.next;      slow = slow.next;    &#125;    return fast != null ? slow.next : slow;&#125;</code></pre><h3 id="返回环的起点"><a href="#返回环的起点" class="headerlink" title="返回环的起点"></a>返回环的起点</h3><p><img src="./image-20220903201209897.png"></p><p>思路: 快慢指针相遇之后, 将慢指针重新指向头节点, 两个指针步长一致, 再次相遇时正好指向环的起点.</p><pre><code class="java">public ListNode detectCycle(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next.next;      slow = slow.next;      if (fast == slow) &#123;        slow = dummy;        int index = -1;        while (fast != null &amp;&amp; fast != slow) &#123;          fast = fast.next;          slow = slow.next;        &#125;        return slow;      &#125;    &#125;    return null;&#125;</code></pre><h2 id="删除倒数第-k-个节点"><a href="#删除倒数第-k-个节点" class="headerlink" title="删除倒数第 k 个节点"></a>删除倒数第 k 个节点</h2><p><strong>删除节点</strong></p><ul><li>例如如下链表 1-&gt;2-&gt;3, 我们如果要删除节点 2, 那么就需要用指针指向节点 2 的上一个节点, 执行 p.next &#x3D; p.next.next 即可.</li></ul><p><strong>dummy节点</strong></p><blockquote><p>dummy-&gt;head-&gt;…</p></blockquote><ul><li>如果我们要删除头节点, 那么我们指针如何指向头节点的上一个节点, 所以需要一个 dummy 节点</li></ul><p><strong>快慢指针</strong></p><blockquote><p>为了定位倒数 k+1 个节点</p><p>dummy-&gt;1-&gt;2-&gt;3(slow)-&gt;4-&gt;5-&gt;6-&gt;null(fast)</p></blockquote><p>当 slow 和 fast 之间始终间隔 k 个节点时, 如果 fast 节点遍历到 null, 那么 slow 节点正好指向倒数第 k+1 个节点</p><pre><code class="java"> public ListNode removeNthFromEnd(ListNode head, int n) &#123;     ListNode dummy = new ListNode();     dummy.next = head;     ListNode fast = head;     ListNode slow = dummy;     // 与 slow 间隔 k 个节点     for (int i = 0; i &lt; n; i++) &#123;       fast = fast.next;     &#125;     while (fast != null) &#123;       slow = slow.next;       fast = fast.next;     &#125;     slow.next = slow.next.next;     return dummy.next; &#125;</code></pre><h2 id="两链表相交节点"><a href="#两链表相交节点" class="headerlink" title="两链表相交节点"></a>两链表相交节点</h2><p>原始两条链表如下</p><p>a1-&gt;a2-&gt;b1-&gt;b2</p><p>c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3</p><p>将链表1和链表2拼接起来, 形成两条长度一样的链表, 可以发现在遍历完之前 b1 节点重合了</p><p>a1-&gt;a2-&gt;b1-&gt;b2-&gt;null-&gt;c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3-&gt;null</p><p>c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3-&gt;null-&gt;a1-&gt;a2-&gt;b1-&gt;b2-&gt;null</p><p>解题的关键是将链表1和链表2拼接起来, 判断的条件是如果在到达最后的 null 节点之前重合了, 那么节点相交</p><pre><code class="java">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;    ListNode p1 = headA;    ListNode p2 = headB;    while (p1 != p2) &#123;      if (p1 == null) &#123;        p1 = headB;      &#125; else &#123;        p1 = p1.next;      &#125;      if (p2 == null) &#123;        p2 = headA;      &#125; else &#123;        p2 = p2.next;      &#125;    &#125;    return p1;&#125;</code></pre><h2 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h2><h3 id="合并两个链表"><a href="#合并两个链表" class="headerlink" title="合并两个链表"></a>合并两个链表</h3><p><strong>dummy 节点</strong></p><ul><li>使用 dummy 节点保存新链表头指针的引用</li></ul><pre><code class="java">public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;    ListNode p1 = list1;    ListNode p2 = list2;    ListNode dummy = new ListNode();    ListNode p = dummy;    while (p1 != null &amp;&amp; p2 != null) &#123;      if (p1.val &gt; p2.val) &#123;        p.next = p2;        p2 = p2.next;      &#125; else &#123;        p.next = p1;        p1 = p1.next;      &#125;      p = p.next;    &#125;    if (p1 != null) &#123;      p.next = p1;    &#125;    if (p2 != null) &#123;      p.next = p2;    &#125;    return dummy.next;&#125;</code></pre><h3 id="合并-k-个链表"><a href="#合并-k-个链表" class="headerlink" title="合并 k 个链表"></a>合并 k 个链表</h3><p><strong>优先级队列</strong></p><ul><li>使用 PriorityQueue 保存不同链表的头节点, 每次从里面取出一个 val 最小的添加到新链表中</li></ul><pre><code class="java">PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((ListNode ln1, ListNode ln2)-&gt;&#123;return ln1.val - ln2.val;&#125;);</code></pre><pre><code class="java">public ListNode mergeKLists(ListNode[] lists) &#123;    PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((ListNode ln1, ListNode ln2)-&gt;&#123;return ln1.val - ln2.val;&#125;);    ListNode dummy = new ListNode();    ListNode p = dummy;    for (ListNode ln: lists) &#123;      if (ln != null) &#123;        pq.offer(ln);      &#125;    &#125;    while (!pq.isEmpty()) &#123;      ListNode n1 = pq.poll();      p.next = n1;      p = p.next;      if (n1.next != null) &#123;        pq.offer(n1.next);      &#125;    &#125;    return dummy.next;&#125;</code></pre><h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h2><p><strong>链表拆分, 注意切断原有联系</strong></p><blockquote><p>原链表: 1-&gt;5-&gt;3-&gt;4-&gt;6</p><p>新链表(smaller): 1-&gt;3-&gt;4(-&gt;6)</p><p>注意节点 4 后面还连着节点 6, 必须把其置为 null.</p></blockquote><pre><code class="java">public ListNode partition(ListNode head, int x) &#123;    ListNode smaller = new ListNode();    ListNode bigger = new ListNode();    ListNode p1 = smaller;    ListNode p2 = bigger;    ListNode p = head;    while (p != null) &#123;      if (p.val &lt; x) &#123;        p1.next = p;        p = p.next;        p1 = p1.next;      &#125; else &#123;        p2.next = p;        p = p.next;        p2 = p2.next;      &#125;    &#125;    // 切断原有联系    p2.next = null;    p1.next = bigger.next;    return smaller.next;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
