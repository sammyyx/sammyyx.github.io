<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring MVC 和 Spring Boot 的区别</title>
      <link href="/2022/09/10/Spring-MVC-%E5%92%8C-Spring-Boot-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/09/10/Spring-MVC-%E5%92%8C-Spring-Boot-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GC算法总结</title>
      <link href="/2022/09/09/GC%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/09/09/GC%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="判断对象是否可以回收"><a href="#判断对象是否可以回收" class="headerlink" title="判断对象是否可以回收"></a>判断对象是否可以回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>每个对象会有一个引用计数器, 记录这个对象被引用的次数. 当引用次数为 0 时, 代表这个对象可以被 GC 回收.</p><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><ul><li>无法处理循环引用的情况.</li><li>堆内对象每一次引用赋值和引用清楚, 都会伴随着加减法的操作, 会带来一定的性能开销.</li></ul><p><strong>循环引用问题</strong></p><pre><code>class A &#123;    private B b;    public void setB(B b) &#123;        this.b = b;    &#125;&#125;class B &#123;    private A a = new A();    public void setA(A a) &#123;        this.a = a;    &#125;&#125;public void method() &#123;    A a = new A();    B b = new B();    a.setB(b);    b.setA(a);&#125;</code></pre><p><img src="./%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.drawio-2775569.png" alt="循环引用计数.drawio"></p><h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>可达性分析法定义了 <code>GC Roots</code> 对象作为起始点, 从这个起点开始向下搜索, 每一条可达路径被称为引用链, 当一个对象没有人意一条引用链可以到达 <code>GC Roots</code> 时, 那么就对这个对象进行第一次可回收标记.</p><h4 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>堆外指向堆内的引用, 下面这些对象可以作为 GC Roots</p><ul><li>代码中某一方法的局部变量</li><li>类静态变量</li><li>常量</li><li>本地方法栈中引用的对象</li><li>已启动且未停止的线程</li></ul><p>以下面代码为例</p><pre><code class="java">class Test &#123;    private static A a = new A(); // 静态变量    public static final String CONTANT = &quot;I am a string&quot;; // 常量    public static void main(String[] args) &#123;        A innerA = new A(); // 局部变量    &#125;&#125;class A &#123;    ...&#125;</code></pre><p>![循环引用计数-第 2 页.drawio](.&#x2F;GC算法总结&#x2F;循环引用计数-第 2 页.drawio-2776592.png)</p><p>此时 GC Roots 状态为</p><p>![循环引用计数-第 3 页.drawio](.&#x2F;GC算法总结&#x2F;循环引用计数-第 3 页.drawio.png)</p><p>当 main 方法执行完毕时, 栈帧出栈, 此时 GC Roots 状态为</p><p>![循环引用计数-第 4 页.drawio](.&#x2F;GC算法总结&#x2F;循环引用计数-第 4 页.drawio-2776947.png)</p><p>此时 A2 被打上标记</p><p>当 GC 判定某一对象不再通过任一形式被引用时, GC 会调用该对象的 finalize 方法, 且一个对象只会执行一次 finalize 方法. 方法被执行时, 可以进行任何操作, 包括将这个对象再次赋值给某一变量引用</p><p><strong>自救</strong>: 在 finalize 方法中, 将这个对象的引用再次赋值给某一变量</p><h3 id="不同引用类型的回收"><a href="#不同引用类型的回收" class="headerlink" title="不同引用类型的回收"></a>不同引用类型的回收</h3><h4 id="2-1-强引用"><a href="#2-1-强引用" class="headerlink" title="2.1 强引用"></a>2.1 强引用</h4><p>通过关键字new的对象就是强引用对象，强引用指向的对象任何时候都不会被回收，宁愿OOM也不会回收。</p><h4 id="2-2-软引用"><a href="#2-2-软引用" class="headerlink" title="2.2 软引用"></a>2.2 软引用</h4><p>如果一个对象持有软引用，那么当JVM堆空间不足时，会被回收。</p><p>一个类的软引用可以通过java.lang.ref.SoftReference持有。</p><h4 id="2-3-弱引用"><a href="#2-3-弱引用" class="headerlink" title="2.3 弱引用"></a>2.3 弱引用</h4><p>如果一个对象持有弱引用，那么在GC时，只要发现弱引用对象，就会被回收。</p><p>一个类的弱引用可以通过java.lang.ref.WeakReference持有。</p><h4 id="2-4-虚引用"><a href="#2-4-虚引用" class="headerlink" title="2.4 虚引用"></a>2.4 虚引用</h4><p>几乎和没有一样，随时可以被回收。</p><p>通过PhantomReference持有。</p><h3 id="STW"><a href="#STW" class="headerlink" title="STW"></a>STW</h3><p><strong>为什么会有 STW</strong>: 如果程序一边执行, 一边进行可达性分析的标记操作, 那么有可能刚标记完一个对象, 这个对象又被再次被赋值给其他的引用. 这样就有可能回收掉正在使用的对象. 解决方式就是使用 STW, STW 会在所有线程到达一个安全点时, 暂停掉所有应用线程的执行, 然后开始专心的标记垃圾对象.</p><p><strong>本质</strong>: 保证数据的一致性.</p><p><strong>安全点</strong>: 引用关系不会发生变化的点</p><h2 id="GC-算法"><a href="#GC-算法" class="headerlink" title="GC 算法"></a>GC 算法</h2><p>三个基础的 GC 算法: 标记-清除, 标记-整理, 复制算法</p><h3 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h3><ul><li>标记阶段: 通过可达性分析将不可达的对象标记出来</li><li>清除阶段: 将标记阶段标记的垃圾对象清除</li></ul><p>缺点: 回收后会产生大量不连续的内存空间(碎片), 由于 Java 在分配内存时通常是按连续内存分配, 所以当碎片空间不足以分配给新对象时, 就会造成内存浪费</p><h3 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h3><ul><li>标记阶段: 通过可达性分析将不可达的对象标记出来</li><li>碎片整理: 将所有存活对象都向一边移动</li><li>清除阶段: 直接清理掉边界外的内存</li></ul><p>缺点: 碎片整理会有性能消耗</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将内存空间分为两块, 每次只使用其中一块内存. 当 GC 执行时, 会将非垃圾对象复制到另一块内存中, 保证内存连续性, 然后直接情况之前使用的内存.</p><p>缺点: 会损失一半的内存</p><h3 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h3><p>复制算法和标记整理算法都有各自适合的使用场景。</p><p>复制算法适用于每次回收时，存活对象少的场景，这样就会减少复制量。</p><p>标记整理算法适用于回收时，存活对象多的场景，这样就会减少内存碎片的产生，碎片整理的代价就会小很多。</p><p>分代算法将内存区域分为两部分：新生代和老年代。</p><p>根据新生代和老年代中对象的不同特点，使用不同的GC算法。</p><p>新生代对象的特点是：创建出来没多久就可以被回收（例如虚拟机栈中创建的对象，方法出栈就会销毁）。也就是说，每次回收时，大部分是垃圾对象，所以新生代适用于复制算法。</p><p>老年代的特点是：经过多次GC，依然存活。也就是说，每次GC时，大部分是存活对象，所以老年代适用于标记整理算法。</p><p><strong>新生代中的不可达对象不一定是垃圾</strong></p><p>![循环引用计数-第 5 页.drawio](.&#x2F;GC算法总结&#x2F;循环引用计数-第 5 页.drawio-2782923.png)</p><p>如上图所示, young 区的 A 对象没有被 GC Roots 引用, 但是却被 old 区对象引用.此时 A 对象不是垃圾. 不能被 GC 掉.</p><p><strong>如何解决?</strong></p><p>引入一个卡表解决. 卡表最简单的形式是一个字节数组.</p><p><code>CARD_TABLE[this address &gt;&gt; 9]=0</code></p><p>HotSpot 中使用的卡页是 2 的 9 次幂, 卡表的每一个元素就对应了容量为 512 字节的内存块. 只要卡页内有一个对象的字段存在跨代指针, 整个卡表的这个元素就会被标识为 1, 因此可以很轻易的判断出哪些内存块中包含跨代指针.</p><h2 id="GC-器"><a href="#GC-器" class="headerlink" title="GC 器"></a>GC 器</h2><h3 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h3><p>CMS 全称 Concurrent Mark Sweep, 是一款并发的、使用标记-清除算法, 针对老年代的垃圾回收器, 其最大的特点就是让垃圾收集线程与用户线程同时工作.</p><p>CMS 收集器的过程</p><ol><li>初始标记, STW, 标记 GCRoots 直接关联的对象</li><li>并发标记, 没有 STW, 可以与用户线程并发运行</li><li>重新标记, STW, 修正并发标记期间用户程序继续运行导致的变动</li><li>并发清除, 不需要移动存活对象</li></ol><p><strong>缺点</strong></p><ul><li>浮动垃圾, 是由并发清理过程导致的, 由于没有 STW, 用户进程会有新垃圾产生<ul><li>-XX:CMSInitialOccupancyFraction</li></ul></li><li>内存碎片<ul><li>-XX:UseCMSCompactAtFullCollection 可以指定开启碎片整理</li><li>XX:CMSFullGCBeforeCompaction 或者是多少次 FGC 后启动碎片整理</li></ul></li><li>对 CPU 资源敏感</li></ul><h3 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h3><p>整体来看, 是基于标记-整理算法实现的收集器</p><p>局部来看, region与region之间是使用的复制算法</p><p><strong>特点</strong></p><ul><li>属于分代型垃圾回收器, 但新生代和老年代步物理隔离, 不用担心每个代内存是否足够</li><li>将整个堆分为 2048 个大小相同的独立 Region 块</li><li>有一个巨型区, 但巨型对象超过分区容量一半时, 会存入巨型区</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GC </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划经典题-编辑距离</title>
      <link href="/2022/09/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E9%A2%98-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
      <url>/2022/09/08/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%BB%8F%E5%85%B8%E9%A2%98-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/edit-distance">https://leetcode.cn/problems/edit-distance</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p><strong>dp数组定义</strong></p><p>有字符串 s1 和 s2, 求 s1 -&gt; s2 的最短距离</p><pre><code>dp[i][j] : s1[0,i] 和 s2[0,j] 的最短编辑距离</code></pre><p><strong>选择对 dp 数组的影响</strong></p><p>当 <code> s1[i] == s2[j]</code> 时, 此时选择跳过当前字符, <code>dp[i][j]=dp[i-1][j-1]</code></p><p>当 <code>s1[i] != s2[j]</code> 时, 此时有三种选择, 取三种选择中最小的一个即可,<code> Math.min(dp[i-1][j]+1,dp[i-1][j-1]+1,dp[i][j-1]+1)</code></p><ul><li>删除当前字符, 那么 <code>dp[i][j]=dp[i-1][j]+1</code></li><li>替换当前字符, 那么 <code>dp[i][j]=dp[i-1][j-1]+1</code></li><li>新增当前字符, 那么<code>dp[i][j]=dp[i][j-1]+1</code></li></ul><h3 id="自顶向下-递归解法"><a href="#自顶向下-递归解法" class="headerlink" title="自顶向下(递归解法)"></a>自顶向下(递归解法)</h3><pre><code class="java">public int minDistance(String word1, String word2) &#123;        int[][] memo = new int[word1.length()][word2.length()];        for (int i = 0; i &lt; word1.length(); i++) &#123;            for (int j = 0; j &lt; word2.length(); j++) &#123;                memo[i][j] = -1;            &#125;        &#125;        return dp(word1, word1.length()-1, word2,word2.length()-1, memo);    &#125;    public int dp(String word1, int i, String word2, int j, int[][] memo) &#123;        if (i == -1) return j+1;        if (j == -1) return i+1;        if (memo[i][j] != -1) return memo[i][j];        if (word1.charAt(i) == word2.charAt(j)) &#123;            memo[i][j] = dp(word1, i-1, word2, j-1, memo);        &#125; else &#123;            memo[i][j] = Math.min(Math.min(dp(word1, i-1, word2, j,memo)+1,dp(word1, i-1, word2, j-1,memo)+1),dp(word1, i, word2, j-1,memo)+1);        &#125;        return memo[i][j];    &#125;</code></pre><h3 id="自底向上-动态规划"><a href="#自底向上-动态规划" class="headerlink" title="自底向上(动态规划)"></a>自底向上(动态规划)</h3><pre><code>if s1[i] == s1[j]: dp[i][j]=dp[i-1][j-1]if s1[i] != s1[j]:     dp[i][j]=min(dp[i-1][j]+1,dp[i-1][j-1]+1,dp[i][j-1]+1)</code></pre><p>从上面的推导公式可以看出, 二维数组 <code>dp[i][j]</code> 这个格子只与其 斜左上, 上, 左 三个格子相关, 即: 只要知道这三个格子的值就能推导出  <code>dp[i][j]</code></p><pre><code class="java">public int minDistance(String word1, String word2) &#123;        int[][] dp = new int[word1.length()+1][word2.length()+1];        for (int i = 0; i &lt;= word1.length(); i++) &#123;            for (int j = 0; j &lt;= word2.length(); j++) &#123;                dp[i][j] = -1;            &#125;        &#125;        for (int i = 0; i &lt;= word1.length(); i++) &#123;            dp[i][0] = i;        &#125;        for (int i = 0; i &lt;= word2.length(); i++) &#123;            dp[0][i] = i;        &#125;        for (int i = 1; i &lt;= word1.length(); i++) &#123;            for (int j = 1; j &lt;= word2.length(); j++) &#123;                if (word1.charAt(i-1) == word2.charAt(j-1)) &#123;                    dp[i][j] = dp[i-1][j-1];                &#125; else &#123;                    dp[i][j] = Math.min(Math.min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1]) + 1;                &#125;            &#125;        &#125;        return dp[word1.length()][word2.length()];    &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列基本原理</title>
      <link href="/2022/09/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2022/09/07/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="消息中间件构成"><a href="#消息中间件构成" class="headerlink" title="消息中间件构成"></a>消息中间件构成</h2><p>一句话介绍: 与 RPC 类似是一种进程间通信的方式, 生产者通过 Broker 将消息存储在队列里, 消费者通过订阅关系取到对应消息.</p><p>使用 MQ 可以将调用过程异步、实现功能解耦、削峰填谷.</p><p>基本架构分为「生产者」、「消费者」和「Broker」</p><p><img src="./%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6.drawio.png"></p><h3 id="消息中间件的设计"><a href="#消息中间件的设计" class="headerlink" title="消息中间件的设计"></a>消息中间件的设计</h3><h4 id="推拉模式的设计"><a href="#推拉模式的设计" class="headerlink" title="推拉模式的设计"></a>推拉模式的设计</h4><p>推拉模式都是消费者主动去和 Broker 建立连接(轮询或长轮询), 然后将消息拉回消费端.</p><blockquote><p>长轮询: 客户端发起 polling 请求, 如果服务端没有相关数据, 会 hold 住请求, 直到服务端有相关数据, 或者等待超时才返回, 返回后客户端会发起下一次 polling 请求.</p><p>轮询: 客户端每隔定长时间请求一次数据, 可能有数据返回, 可能没有.</p><p>长轮询为什么需要超时时间: tcp 三次握手建立的连接会通过底层 keep alive 计时器保证, 但这个连接失活发现太慢了, 消费端不能依赖这个保活手段, 所以设计了超时时间.</p></blockquote><p>推拉模式在消息中间件中如何定义?</p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程-基础求和问题</title>
      <link href="/2022/09/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-…-100求和问题"><a href="#1-…-100求和问题" class="headerlink" title="1+…+100求和问题"></a>1+…+100求和问题</h2><h3 id="FutureTask-Callable"><a href="#FutureTask-Callable" class="headerlink" title="FutureTask+Callable"></a>FutureTask+Callable</h3><pre><code class="java">package com.samyyx.test;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * 1+...+n */public final class App &#123;    static class Adder implements Callable&lt;Long&gt; &#123;        private long start;        private long end;        public Adder(long start, long end) &#123;            this.start = start;            this.end = end;        &#125;        @Override        public Long call() throws Exception &#123;            System.out.println(Thread.currentThread().getId());            long sum = 0;            for (long i = start; i &lt;= end; i++) &#123;                sum += i;            &#125;            return sum;        &#125;    &#125;    public static void main(String[] args) &#123;        // 并发执行        FutureTask&lt;Long&gt; f1 = new FutureTask&lt;&gt;(new Adder(1, n / 2));        FutureTask&lt;Long&gt; f2 = new FutureTask&lt;&gt;(new Adder(n / 2 + 1, n));        Thread t1 = new Thread(f1);        Thread t2 = new Thread(f2);        t1.start();        t2.start();        try &#123;            long sum = f1.get() + f2.get();            System.out.println(&quot;parallel sum:&quot;+sum);            long cost = System.currentTimeMillis() - cur;            System.out.println(&quot;parallel cost:&quot; + cost);        &#125; catch (InterruptedException | ExecutionException e) &#123;            e.printStackTrace();        &#125;          // 串行执行        cur = System.currentTimeMillis();        long sum = 0;        for (long i = 1; i &lt;= n; i++) &#123;            sum += i;        &#125;        System.out.println(&quot;serial sum:&quot;+sum);        long cost = System.currentTimeMillis() - cur;        System.out.println(&quot;serial cost:&quot; + cost);    &#125;&#125;</code></pre><h3 id="countDownLatch"><a href="#countDownLatch" class="headerlink" title="countDownLatch"></a>countDownLatch</h3><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法基本框架</title>
      <link href="/2022/09/06/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/"/>
      <url>/2022/09/06/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><pre><code class="java">private void traverse(...) &#123;    if (是否可以终止?) &#123;          // 结果保存        return;    &#125;    for (选择: 所有选择) &#123;        // 进行选择        traverse(...);        // 撤销选择    &#125;&#125;</code></pre><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p><strong>visited 数组</strong></p><ul><li>使用 visited 数组记录数组中元素的使用, 跳过使用过的元素</li></ul><pre><code class="java">List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();private void traverse(int[] nums, boolean[] visited, LinkedList&lt;Integer&gt; track) &#123;    if (track.size() == nums.length) &#123;        List&lt;Integer&gt; copy = new LinkedList&lt;&gt;(track);        result.add(copy);        return;    &#125;    for (int i = 0; i &lt; nums.length; i++) &#123;        if (visited[i]) continue;        track.add(nums[i]);        visited[i] = true;        traverse(nums, visited, track);        visited[i] = false;        track.removeLast();    &#125;&#125;public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;    boolean[] visited = new boolean[nums.length];    LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;();    traverse(nums, visited, track);    return result;&#125;</code></pre><h2 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h2><p><strong>判断是否可以放皇后</strong></p><ul><li>由于是逐行放皇后, 所以仅需考虑「与皇后同列」、「皇后左上」、「皇后右上」</li></ul><pre><code class="java">List&lt;List&lt;String&gt;&gt; result = new LinkedList&lt;&gt;();private void traverse(LinkedList&lt;String&gt; board, int curRow, int n) &#123;    if (board.size() == n) &#123;        result.add(new LinkedList&lt;&gt;(board));        return;    &#125;    for (int j = 0; j &lt; n; j++) &#123;        if (isValid(board, curRow, j, n)) &#123;            board.add(newBoard(n, j));            traverse(board, curRow + 1, n);            board.removeLast();        &#125;    &#125;&#125;private String newBoard(int n, int j) &#123;    String s = &quot;&quot;;    for (int i = 0; i &lt; n; i++) &#123;        if (i == j)            s += &quot;Q&quot;;        else            s += &quot;.&quot;;    &#125;    return s;&#125;private boolean isValid(List&lt;String&gt; board, int row, int column, int n) &#123;    // 同列    for (String s : board) &#123;        if (s.charAt(column) == &#39;Q&#39;)            return false;    &#125;    // 左上    for (int i = row - 1, j = column - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123;        if (board.get(i).charAt(j) == &#39;Q&#39;)            return false;    &#125;    // 右上    for (int i = row - 1, j = column + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123;        if (board.get(i).charAt(j) == &#39;Q&#39;)            return false;    &#125;    return true;&#125;public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;    LinkedList&lt;String&gt; board = new LinkedList&lt;&gt;();    traverse(board, 0, n);    return result;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划基本框架</title>
      <link href="/2022/09/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/"/>
      <url>/2022/09/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>递推公式:</p><p><code>f(n)=f(n-1)+f(n-2)</code></p><p><code>f(0)=0,f(1)=1</code></p><pre><code class="java">public int fib(int n) &#123;    if (n == 0) &#123;        return 0;    &#125;    if (n == 1) &#123;        return 1;    &#125;    int[] dp = new int[n+1];    dp[0] = 0;    dp[1] = 1;    for (int i = 2; i &lt; n+1; i++) &#123;        dp[i] = dp[i-1] + dp[i-2];    &#125;    return dp[n];&#125;</code></pre><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><h3 id="自顶向下-递归"><a href="#自顶向下-递归" class="headerlink" title="自顶向下(递归)"></a>自顶向下(递归)</h3><p><strong>备忘录</strong></p><ul><li><p>使用 memo 数组保存已经递归出结果的值(剪枝)</p></li><li><p>memo 数组初始化</p><ul><li>最大值为 amount + 1(没有比面值为1的硬币更小的)</li></ul></li></ul><p><strong>无解判断</strong></p><ul><li>若遍历完所有可能后, memo 值还是最大值, 则置为 -1 表示无解</li></ul><pre><code class="java">private int traverse(int[] coins, int amount, int[] memo) &#123;    if (memo[amount] != amount + 1) &#123;        return memo[amount];    &#125;    for (int i = 0; i &lt; coins.length; i++) &#123;        if (amount - coins[i] &gt;= 0) &#123;            int num = traverse(coins, amount-coins[i], memo);            if (num == -1) continue;            if (memo[amount] &gt; num + 1) &#123;                memo[amount] = num + 1;            &#125;        &#125;    &#125;    if (memo[amount] == amount + 1) &#123;      memo[amount] = -1;    &#125;    return memo[amount];&#125;public int coinChange(int[] coins, int amount) &#123;    int[] memo = new int[amount+1];    for (int i = 0; i &lt; amount + 1; i++) &#123;        memo[i] = i+1;    &#125;    memo[0] =  0;    int result = traverse(coins, amount, memo);    return result;&#125;</code></pre><h3 id="自低向上-动态规划"><a href="#自低向上-动态规划" class="headerlink" title="自低向上(动态规划)"></a>自低向上(动态规划)</h3><p><code>f(coin)=1,coin in coins</code> </p><p><code>f(coin+f(n))=f(n)+1, coin in coins, f(n) != n+1</code> </p><p><strong>版本一</strong></p><pre><code class="java">public int coinChange(int[] coins, int amount) &#123;    boolean[] visited = new boolean[amount+1];    if (amount == 0) return 0;    int[] dp = new int[amount+1];    for (int i = 0; i &lt; amount + 1; i++) &#123;        dp[i] = i+1;    &#125;    Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();    for (int i = 0; i &lt; coins.length; i++) &#123;        if (coins[i] &lt;= amount) &#123;            dp[coins[i]] = 1;            q.offer(coins[i]);        &#125;    &#125;    while (!q.isEmpty()) &#123;        long cur = q.poll();        for (int i = 0; i &lt; coins.length; i++) &#123;            long coinL = coins[i];              // 部分case cur+coin 会超出 int 范围, 所以需要使用 long            long target = cur+coinL;            if (target &gt; amount) continue;            if (dp[(int)cur] + 1 &lt; dp[(int)target]) &#123;                dp[(int)target] = dp[(int)cur] + 1;                  // 剪枝                if (!visited[(int)target]) &#123;                    q.offer((int)target);                    visited[(int)target] = true;                &#125;            &#125;        &#125;    &#125;    return dp[amount] == amount + 1 ? -1 : dp[amount];&#125;</code></pre><p>可以看出这个版本缺点很明显, 需要额外的存储空间, 而且需要考虑 int 范围问题</p><p><strong>版本二</strong></p><p>调整下遍历逻辑, 外层循环从 1 遍历到 amount, 内层循环所有可能的选择.</p><pre><code class="java">public int coinChange(int[] coins, int amount) &#123;    int[] dp = new int[amount+1];    dp[0] = 0;    for (int i = 1; i &lt; amount + 1; i++) &#123;        dp[i] = i + 1;    &#125;    for (int i = 1; i &lt; amount + 1; i++) &#123;        for (int coin: coins) &#123;            if (i - coin &lt; 0) continue;            if (dp[i-coin] == i-coin+1) continue;            dp[i] = Math.min(dp[i-coin]+1, dp[i]);        &#125;    &#125;    return dp[amount] == amount + 1 ? -1 : dp[amount]; &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归二叉树</title>
      <link href="/2022/09/05/%E9%80%92%E5%BD%92%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/09/05/%E9%80%92%E5%BD%92%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前-x2F-中-x2F-后序遍历"><a href="#前-x2F-中-x2F-后序遍历" class="headerlink" title="前&#x2F;中&#x2F;后序遍历"></a>前&#x2F;中&#x2F;后序遍历</h2><p><strong>递归</strong></p><ul><li>只要是递归调用, 就存在前序和后序<ul><li>前序指递归前</li><li>后序指递归后</li></ul></li><li>由于二叉树需要先后递归左右子树, 在两次递归之间称为中序</li></ul><pre><code class="java">private List&lt;Integer&gt; track = new ArrayList&lt;&gt;();private void traverse(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    track.add(root.val);    traverse(root.left);      // 中序遍历 track.add(root.val);    traverse(root.right);      // 后序遍历 track.add(root.val);&#125;public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;    traverse(root);    return track;&#125;</code></pre><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p><strong>最大深度</strong>: 根节点到「最远」叶子节点的最长路径上的节点个数</p><p><strong>思路</strong>: 遍历所有「叶子节点」, 比较「根节点」到所有「叶子节点」的长度, 取最大的一个</p><pre><code class="java">private int maxDepth = 0;private void traverse(TreeNode root, int depth) &#123;    if (root == null) &#123;        return;    &#125;    if (root.left == null &amp;&amp; root.right == null) &#123;        maxDepth = Math.max(maxDepth, depth);    &#125;    traverse(root.left, depth+1);    traverse(root.right, depth+1);&#125;public int maxDepth(TreeNode root) &#123;    traverse(root, 1);    return maxDepth;&#125;</code></pre><h2 id="利用后序位置搜集子树的信息"><a href="#利用后序位置搜集子树的信息" class="headerlink" title="利用后序位置搜集子树的信息"></a>利用后序位置搜集子树的信息</h2><h3 id="统计二叉树节点个数"><a href="#统计二叉树节点个数" class="headerlink" title="统计二叉树节点个数"></a>统计二叉树节点个数</h3><p>由于后序是在递归之后发生, 可以理解后序是站在根节点观察左右子树, 在这个位置可以拿到左右子树的遍历结果.</p><p>当前根节点对应的子树包含的节点个数 &#x3D; 「左子树」的节点个数 + 「右子树」的节点个数 + 1「根节点」</p><pre><code class="java">private int count = 0;private int traverse(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    int left = traverse(root.left);    int right = traverse(root.right);    // 「左子树」的节点个数 + 「右子树」的节点个数 + 1「根节点」    count = Math.max(left+right+1, count);    return left+right+1;&#125;public int countNodeOfBinaryTree(TreeNode root) &#123;    traverse(root);    return count;&#125;</code></pre><h3 id="二叉树的最长直径"><a href="#二叉树的最长直径" class="headerlink" title="二叉树的最长直径"></a>二叉树的最长直径</h3><p>「当前子树的最长直径」&#x3D; 其「左子树」的深度 + 其「右子树」的深度</p><pre><code class="java">private int diameter = 0;private int traverse(TreeNode root) &#123;    if (root == null) &#123;          return 0;    &#125;    int left = traverse(root.left);    int right = traverse(root.right);      // 「左子树」的深度 + 其「右子树」的深度    diameter = Math.max(left+right, diameter);    return Math.max(left, right) + 1;&#125;public int diameterOfBinaryTree(TreeNode root) &#123;    traverse(root);    return diameter;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组集合技巧合集</title>
      <link href="/2022/09/05/Java%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/"/>
      <url>/2022/09/05/Java%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p><strong>Arrays</strong></p><ul><li>Arrays 工具类中封装了大量的排序算法, 对于升序排序, 直接使用 Arrays.sort 即可.</li><li>如果想对数组类进行逆序排序&#x2F;自定义comparator排序<ul><li>包装类<ul><li><code>Arrays.sort(array, Arrays.sort(nums, (a,b)-&gt;&#123;return b-a;&#125;);)</code></li></ul></li><li>基本类型<ul><li><code>int[] sorted = Arrays.stream(nums).boxed().sorted((a,b)-&gt;&#123;return b-a;&#125;).mapToInt(a-&gt;a).toArray();</code></li></ul></li></ul></li></ul><h2 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h2><p><strong>基本类型数组-&gt;包装类数组</strong></p><ul><li><code>Integer[] sorted = Arrays.stream(nums).boxed().toArray(Integer[]::new);</code></li></ul><p><strong>基本类型数组-&gt;包装类集合</strong></p><ul><li><code>List&lt;Integer&gt; array = Arrays.stream(nums).boxed().collect(Collectors.toList());</code></li></ul><h2 id="集合排序"><a href="#集合排序" class="headerlink" title="集合排序"></a>集合排序</h2><p><strong>Collections</strong></p><ul><li><code>Collections.sort(array, (a,b)-&gt;&#123;return b-a;&#125;);</code></li></ul><h2 id="集合转换"><a href="#集合转换" class="headerlink" title="集合转换"></a>集合转换</h2><p><strong>包装类集合-&gt;包装类数组</strong></p><ul><li><code>Integer[] nums = array.stream().toArray(Integer[]::new);</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组双指针</title>
      <link href="/2022/09/02/%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2022/09/02/%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><strong>排序</strong></p><ul><li>使数组成为有序数组</li></ul><p><strong>左右指针</strong></p><ul><li>左右指针分别指向数组第一个元素和数组最后一个元素<ul><li><code>num[left]+num[right]&gt;target:right--;</code></li><li><code>num[left]+num[right]&lt;target:left++;</code></li></ul></li></ul><pre><code class="java">public int[] twoSum(int[] numbers, int target) &#123;    int left = 0;    int right = numbers.length - 1;    while (left &lt; right) &#123;      int p = numbers[left] + numbers[right];      if (p == target) &#123;        return new int[]&#123;left+1, right+1&#125;;      &#125; else if (p &gt; target) &#123;        right--;      &#125; else &#123;        left++;      &#125;    &#125;    return null;&#125;</code></pre><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p><strong>two sum 改造</strong></p><ul><li>增加一个搜索范围, lo, hi</li><li>成功找到一组后, lo 从下一个不同的地方开始</li></ul><pre><code class="java">public List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int lo, int hi, int target) &#123;    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    int left = lo;    int right = hi;    while (left &lt; right) &#123;        int nleft = nums[left];        int nright = nums[right];        int p = nleft + nright;        if (p == target) &#123;            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(Arrays.asList(nleft, nright, nums[lo-1]));            result.add(tmp);            while (nums[left] == nleft &amp;&amp; left &lt; right) &#123;              left++;            &#125;        &#125; else if (p &gt; target) &#123;            right--;        &#125; else &#123;            left++;        &#125;    &#125;    return result;&#125;</code></pre><p><strong>总体思路</strong></p><ul><li><p>对数组排序</p></li><li><p>外层循环遍历数组, i&#x3D;[0, length-3]</p></li><li><p><code>twoSum(numbers, i+1, length-1, target-nums[i])</code></p><ul><li>如果返回值为 null, 外层继续遍历</li><li>如果返回值不为 null, 加入结果集, 继续遍历</li></ul></li></ul><pre><code class="java">public List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int lo, int hi, int target) &#123;    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    int left = lo;    int right = hi;    while (left &lt; right) &#123;        int nleft = nums[left];        int nright = nums[right];        int p = nleft + nright;        if (p == target) &#123;            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(Arrays.asList(nleft, nright, nums[lo-1]));            result.add(tmp);            while (nums[left] == nleft &amp;&amp; left &lt; right) &#123;              left++;            &#125;        &#125; else if (p &gt; target) &#123;            right--;        &#125; else &#123;            left++;        &#125;    &#125;    return result;&#125;public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    Arrays.sort(nums);    for (int i = 0; i &lt; nums.length-2; i++) &#123;        int num = nums[i];        List&lt;List&lt;Integer&gt;&gt; twoSumResult = twoSum(nums, i+1, nums.length-1, 0-num);        if (!twoSumResult.isEmpty()) &#123;            result.addAll(twoSumResult);            while (i+1 &lt; nums.length-2 &amp;&amp; num == nums[i+1]) &#123;              i++;            &#125;        &#125;    &#125;    return result;&#125;</code></pre><h2 id="原地操作数组"><a href="#原地操作数组" class="headerlink" title="原地操作数组"></a>原地操作数组</h2><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><ul><li>双指针, lo 指向待写入的下标, hi 指向写入值对应的下标</li></ul><pre><code class="java">public int removeElement(int[] nums, int val) &#123;    int lo = 0;    int hi = 0;    while (hi &lt; nums.length) &#123;      if (nums[hi] != val) &#123;        nums[lo] = nums[hi];        lo++;      &#125;      hi++;    &#125;    return lo;&#125;</code></pre><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h3><ul><li>移除值为 0 的元素, 然后将 <code>[lo,nums.length-1]</code> 都置为 0</li></ul><pre><code class="java">public void moveZeroes(int[] nums) &#123;    int lo = 0;    int hi = 0;    while (hi &lt; nums.length) &#123;      if (nums[hi] != 0) &#123;        nums[lo] = nums[hi];        lo++;      &#125;      hi++;    &#125;    for (int i = lo; i &lt; nums.length; i++) &#123;      nums[i] = 0;    &#125;&#125;</code></pre><h3 id="删除数组当中的重复项"><a href="#删除数组当中的重复项" class="headerlink" title="删除数组当中的重复项"></a>删除数组当中的重复项</h3><ul><li>数组是否为有序? <ul><li>无序先排序</li><li>有序, lo 指向待写入的下标(待写入的下标为被比较值下标+1), hi 指向待写入的值</li></ul></li></ul><pre><code class="java">public int removeDuplicates(int[] nums) &#123;    int lo = 0;    int hi = lo + 1;    while (hi &lt; nums.length) &#123;      // nums[lo]-&gt;被比较值      if (nums[hi] != nums[lo]) &#123;        // 指向待写入的下标        lo++;        nums[lo] = nums[hi];      &#125;      hi++;    &#125;    return lo+1;&#125;</code></pre><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><strong>回文子串的定义</strong></p><ul><li>回文子串有两种, 奇数长度 or 偶数长度<ul><li>奇数长度, 双指针从同一个中点像外扩散, 直到两个指针指向的值不相等</li><li>偶数长度, 双指针从相邻的中点像外扩散, 直到两个指针指向的值不相等</li></ul></li><li>由于最长回文子串的中点有可能是原始字符串中的任意一个元素, 所以外层需要遍历 s 的每一个字符</li></ul><p><strong>思路</strong>: 遍历原始字符串中每个元素, 尝试以当前元素(奇偶情况)作为回文子串的中点并向外扩散</p><pre><code class="java">private String longest(String s, int i, int j) &#123;    int len = s.length();    while (i &gt;= 0 &amp;&amp; j &lt; len &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;        i--;        j++;    &#125;    return s.substring(i+1, j);&#125;public String longestPalindrome(String s) &#123;    String max = &quot;&quot;;    for (int i = 0; i &lt; s.length(); i++) &#123;        String result1 = longest(s, i, i);        if (max.length() &lt; result1.length()) &#123;            max = result1;        &#125;        if (i+1 &lt; s.length()) &#123;            String result2 = longest(s, i, i+1);            if (max.length() &lt; result2.length()) &#123;                max = result2;            &#125;        &#125;    &#125;    return max;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表双指针</title>
      <link href="/2022/08/10/%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2022/08/10/%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="链表成环"><a href="#链表成环" class="headerlink" title="链表成环"></a>链表成环</h2><h3 id="判断链表成环"><a href="#判断链表成环" class="headerlink" title="判断链表成环"></a>判断链表成环</h3><p><strong>dummy 头节点</strong></p><ul><li>使用 <strong>dummy</strong> 头节点避免空指针</li></ul><p><strong>快慢指针</strong></p><ul><li>快指针走两步, 慢指针走一步, 如果快指针走到末尾节点仍未和慢指针相遇, 则链表无反, 反之, 有环</li></ul><pre><code class="java">public boolean hasCycle(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next了;.next;      slow = slow.next;      if (fast == slow) &#123;        return true;      &#125;    &#125;    return false;&#125;</code></pre><h2 id="找到链表中点"><a href="#找到链表中点" class="headerlink" title="找到链表中点"></a>找到链表中点</h2><p>典型快慢指针, 判断链表成环类似</p><p><strong>dummy 头节点</strong></p><ul><li>使用 <strong>dummy</strong> 头节点避免空指针</li></ul><p><strong>快慢指针(终止条件)</strong></p><ul><li>if fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null, 快指针走两步, 慢指针走一步, if fast.next &#x3D;&#x3D; null: return slow;</li></ul><blockquote><p>长度为奇数</p><p>1-&gt;2(slow)-&gt;3-&gt;null(fast)</p><p>长度为偶数</p><p>1-&gt;2(slow)-&gt;3-&gt;4(fast)-&gt;null</p></blockquote><p><strong>举一反三</strong></p><ul><li>上述终止条件对应偶数长度时, 返回的是靠前的中间节点, 如何返回靠后的?<ul><li><code>return fast != null ? slow.next ? slow;</code></li></ul></li></ul><pre><code class="java">public ListNode middleNode(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next.next;      slow = slow.next;    &#125;    return fast != null ? slow.next : slow;&#125;</code></pre><h3 id="返回环的起点"><a href="#返回环的起点" class="headerlink" title="返回环的起点"></a>返回环的起点</h3><p><img src="./image-20220903201209897.png"></p><p>思路: 快慢指针相遇之后, 将慢指针重新指向头节点, 两个指针步长一致, 再次相遇时正好指向环的起点.</p><pre><code class="java">public ListNode detectCycle(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next.next;      slow = slow.next;      if (fast == slow) &#123;        slow = dummy;        int index = -1;        while (fast != null &amp;&amp; fast != slow) &#123;          fast = fast.next;          slow = slow.next;        &#125;        return slow;      &#125;    &#125;    return null;&#125;</code></pre><h2 id="删除倒数第-k-个节点"><a href="#删除倒数第-k-个节点" class="headerlink" title="删除倒数第 k 个节点"></a>删除倒数第 k 个节点</h2><p><strong>删除节点</strong></p><ul><li>例如如下链表 1-&gt;2-&gt;3, 我们如果要删除节点 2, 那么就需要用指针指向节点 2 的上一个节点, 执行 p.next &#x3D; p.next.next 即可.</li></ul><p><strong>dummy节点</strong></p><blockquote><p>dummy-&gt;head-&gt;…</p></blockquote><ul><li>如果我们要删除头节点, 那么我们指针如何指向头节点的上一个节点, 所以需要一个 dummy 节点</li></ul><p><strong>快慢指针</strong></p><blockquote><p>为了定位倒数 k+1 个节点</p><p>dummy-&gt;1-&gt;2-&gt;3(slow)-&gt;4-&gt;5-&gt;6-&gt;null(fast)</p></blockquote><p>当 slow 和 fast 之间始终间隔 k 个节点时, 如果 fast 节点遍历到 null, 那么 slow 节点正好指向倒数第 k+1 个节点</p><pre><code class="java"> public ListNode removeNthFromEnd(ListNode head, int n) &#123;     ListNode dummy = new ListNode();     dummy.next = head;     ListNode fast = head;     ListNode slow = dummy;     // 与 slow 间隔 k 个节点     for (int i = 0; i &lt; n; i++) &#123;       fast = fast.next;     &#125;     while (fast != null) &#123;       slow = slow.next;       fast = fast.next;     &#125;     slow.next = slow.next.next;     return dummy.next; &#125;</code></pre><h2 id="两链表相交节点"><a href="#两链表相交节点" class="headerlink" title="两链表相交节点"></a>两链表相交节点</h2><p>原始两条链表如下</p><p>a1-&gt;a2-&gt;b1-&gt;b2</p><p>c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3</p><p>将链表1和链表2拼接起来, 形成两条长度一样的链表, 可以发现在遍历完之前 b1 节点重合了</p><p>a1-&gt;a2-&gt;b1-&gt;b2-&gt;null-&gt;c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3-&gt;null</p><p>c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3-&gt;null-&gt;a1-&gt;a2-&gt;b1-&gt;b2-&gt;null</p><p>解题的关键是将链表1和链表2拼接起来, 判断的条件是如果在到达最后的 null 节点之前重合了, 那么节点相交</p><pre><code class="java">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;    ListNode p1 = headA;    ListNode p2 = headB;    while (p1 != p2) &#123;      if (p1 == null) &#123;        p1 = headB;      &#125; else &#123;        p1 = p1.next;      &#125;      if (p2 == null) &#123;        p2 = headA;      &#125; else &#123;        p2 = p2.next;      &#125;    &#125;    return p1;&#125;</code></pre><h2 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h2><h3 id="合并两个链表"><a href="#合并两个链表" class="headerlink" title="合并两个链表"></a>合并两个链表</h3><p><strong>dummy 节点</strong></p><ul><li>使用 dummy 节点保存新链表头指针的引用</li></ul><pre><code class="java">public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;    ListNode p1 = list1;    ListNode p2 = list2;    ListNode dummy = new ListNode();    ListNode p = dummy;    while (p1 != null &amp;&amp; p2 != null) &#123;      if (p1.val &gt; p2.val) &#123;        p.next = p2;        p2 = p2.next;      &#125; else &#123;        p.next = p1;        p1 = p1.next;      &#125;      p = p.next;    &#125;    if (p1 != null) &#123;      p.next = p1;    &#125;    if (p2 != null) &#123;      p.next = p2;    &#125;    return dummy.next;&#125;</code></pre><h3 id="合并-k-个链表"><a href="#合并-k-个链表" class="headerlink" title="合并 k 个链表"></a>合并 k 个链表</h3><p><strong>优先级队列</strong></p><ul><li>使用 PriorityQueue 保存不同链表的头节点, 每次从里面取出一个 val 最小的添加到新链表中</li></ul><pre><code class="java">PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((ListNode ln1, ListNode ln2)-&gt;&#123;return ln1.val - ln2.val;&#125;);</code></pre><pre><code class="java">public ListNode mergeKLists(ListNode[] lists) &#123;    PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((ListNode ln1, ListNode ln2)-&gt;&#123;return ln1.val - ln2.val;&#125;);    ListNode dummy = new ListNode();    ListNode p = dummy;    for (ListNode ln: lists) &#123;      if (ln != null) &#123;        pq.offer(ln);      &#125;    &#125;    while (!pq.isEmpty()) &#123;      ListNode n1 = pq.poll();      p.next = n1;      p = p.next;      if (n1.next != null) &#123;        pq.offer(n1.next);      &#125;    &#125;    return dummy.next;&#125;</code></pre><h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h2><p><strong>链表拆分, 注意切断原有联系</strong></p><blockquote><p>原链表: 1-&gt;5-&gt;3-&gt;4-&gt;6</p><p>新链表(smaller): 1-&gt;3-&gt;4(-&gt;6)</p><p>注意节点 4 后面还连着节点 6, 必须把其置为 null.</p></blockquote><pre><code class="java">public ListNode partition(ListNode head, int x) &#123;    ListNode smaller = new ListNode();    ListNode bigger = new ListNode();    ListNode p1 = smaller;    ListNode p2 = bigger;    ListNode p = head;    while (p != null) &#123;      if (p.val &lt; x) &#123;        p1.next = p;        p = p.next;        p1 = p1.next;      &#125; else &#123;        p2.next = p;        p = p.next;        p2 = p2.next;      &#125;    &#125;    // 切断原有联系    p2.next = null;    p1.next = bigger.next;    return smaller.next;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
