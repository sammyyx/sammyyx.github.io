<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并发编程-基础求和问题</title>
      <link href="/2022/09/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2022/09/06/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80%E6%B1%82%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法基本框架</title>
      <link href="/2022/09/06/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/"/>
      <url>/2022/09/06/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h2><pre><code class="java">private void traverse(...) &#123;    if (是否可以终止?) &#123;          // 结果保存        return;    &#125;    for (选择: 所有选择) &#123;        // 进行选择        traverse(...);        // 撤销选择    &#125;&#125;</code></pre><h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p><strong>visited 数组</strong></p><ul><li>使用 visited 数组记录数组中元素的使用, 跳过使用过的元素</li></ul><pre><code class="java">List&lt;List&lt;Integer&gt;&gt; result = new LinkedList&lt;&gt;();private void traverse(int[] nums, boolean[] visited, LinkedList&lt;Integer&gt; track) &#123;    if (track.size() == nums.length) &#123;        List&lt;Integer&gt; copy = new LinkedList&lt;&gt;(track);        result.add(copy);        return;    &#125;    for (int i = 0; i &lt; nums.length; i++) &#123;        if (visited[i]) continue;        track.add(nums[i]);        visited[i] = true;        traverse(nums, visited, track);        visited[i] = false;        track.removeLast();    &#125;&#125;public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;    boolean[] visited = new boolean[nums.length];    LinkedList&lt;Integer&gt; track = new LinkedList&lt;&gt;();    traverse(nums, visited, track);    return result;&#125;</code></pre><h2 id="N皇后问题"><a href="#N皇后问题" class="headerlink" title="N皇后问题"></a>N皇后问题</h2><p><strong>判断是否可以放皇后</strong></p><ul><li>由于是逐行放皇后, 所以仅需考虑「与皇后同列」、「皇后左上」、「皇后右上」</li></ul><pre><code class="java">List&lt;List&lt;String&gt;&gt; result = new LinkedList&lt;&gt;();private void traverse(LinkedList&lt;String&gt; board, int curRow, int n) &#123;    if (board.size() == n) &#123;        result.add(new LinkedList&lt;&gt;(board));        return;    &#125;    for (int j = 0; j &lt; n; j++) &#123;        if (isValid(board, curRow, j, n)) &#123;            board.add(newBoard(n, j));            traverse(board, curRow + 1, n);            board.removeLast();        &#125;    &#125;&#125;private String newBoard(int n, int j) &#123;    String s = &quot;&quot;;    for (int i = 0; i &lt; n; i++) &#123;        if (i == j)            s += &quot;Q&quot;;        else            s += &quot;.&quot;;    &#125;    return s;&#125;private boolean isValid(List&lt;String&gt; board, int row, int column, int n) &#123;    // 同列    for (String s : board) &#123;        if (s.charAt(column) == &#39;Q&#39;)            return false;    &#125;    // 左上    for (int i = row - 1, j = column - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123;        if (board.get(i).charAt(j) == &#39;Q&#39;)            return false;    &#125;    // 右上    for (int i = row - 1, j = column + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123;        if (board.get(i).charAt(j) == &#39;Q&#39;)            return false;    &#125;    return true;&#125;public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;    LinkedList&lt;String&gt; board = new LinkedList&lt;&gt;();    traverse(board, 0, n);    return result;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划基本框架</title>
      <link href="/2022/09/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/"/>
      <url>/2022/09/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>递推公式:</p><p><code>f(n)=f(n-1)+f(n-2)</code></p><p><code>f(0)=0,f(1)=1</code></p><pre><code class="java">public int fib(int n) &#123;    if (n == 0) &#123;        return 0;    &#125;    if (n == 1) &#123;        return 1;    &#125;    int[] dp = new int[n+1];    dp[0] = 0;    dp[1] = 1;    for (int i = 2; i &lt; n+1; i++) &#123;        dp[i] = dp[i-1] + dp[i-2];    &#125;    return dp[n];&#125;</code></pre><h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><h3 id="自顶向下-递归"><a href="#自顶向下-递归" class="headerlink" title="自顶向下(递归)"></a>自顶向下(递归)</h3><p><strong>备忘录</strong></p><ul><li><p>使用 memo 数组保存已经递归出结果的值(剪枝)</p></li><li><p>memo 数组初始化</p><ul><li>最大值为 amount + 1(没有比面值为1的硬币更小的)</li></ul></li></ul><p><strong>无解判断</strong></p><ul><li>若遍历完所有可能后, memo 值还是最大值, 则置为 -1 表示无解</li></ul><pre><code class="java">private int traverse(int[] coins, int amount, int[] memo) &#123;    if (memo[amount] != amount + 1) &#123;        return memo[amount];    &#125;    for (int i = 0; i &lt; coins.length; i++) &#123;        if (amount - coins[i] &gt;= 0) &#123;            int num = traverse(coins, amount-coins[i], memo);            if (num == -1) continue;            if (memo[amount] &gt; num + 1) &#123;                memo[amount] = num + 1;            &#125;        &#125;    &#125;    if (memo[amount] == amount + 1) &#123;      memo[amount] = -1;    &#125;    return memo[amount];&#125;public int coinChange(int[] coins, int amount) &#123;    int[] memo = new int[amount+1];    for (int i = 0; i &lt; amount + 1; i++) &#123;        memo[i] = i+1;    &#125;    memo[0] =  0;    int result = traverse(coins, amount, memo);    return result;&#125;</code></pre><h3 id="自低向上-动态规划"><a href="#自低向上-动态规划" class="headerlink" title="自低向上(动态规划)"></a>自低向上(动态规划)</h3><p><code>f(coin)=1,coin in coins</code> </p><p><code>f(coin+f(n))=f(n)+1, coin in coins, f(n) != n+1</code> </p><p><strong>版本一</strong></p><pre><code class="java">public int coinChange(int[] coins, int amount) &#123;    boolean[] visited = new boolean[amount+1];    if (amount == 0) return 0;    int[] dp = new int[amount+1];    for (int i = 0; i &lt; amount + 1; i++) &#123;        dp[i] = i+1;    &#125;    Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();    for (int i = 0; i &lt; coins.length; i++) &#123;        if (coins[i] &lt;= amount) &#123;            dp[coins[i]] = 1;            q.offer(coins[i]);        &#125;    &#125;    while (!q.isEmpty()) &#123;        long cur = q.poll();        for (int i = 0; i &lt; coins.length; i++) &#123;            long coinL = coins[i];              // 部分case cur+coin 会超出 int 范围, 所以需要使用 long            long target = cur+coinL;            if (target &gt; amount) continue;            if (dp[(int)cur] + 1 &lt; dp[(int)target]) &#123;                dp[(int)target] = dp[(int)cur] + 1;                  // 剪枝                if (!visited[(int)target]) &#123;                    q.offer((int)target);                    visited[(int)target] = true;                &#125;            &#125;        &#125;    &#125;    return dp[amount] == amount + 1 ? -1 : dp[amount];&#125;</code></pre><p>可以看出这个版本缺点很明显, 需要额外的存储空间, 而且需要考虑 int 范围问题</p><p><strong>版本二</strong></p><p>调整下遍历逻辑, 外层循环从 1 遍历到 amount, 内层循环所有可能的选择.</p><pre><code class="java">public int coinChange(int[] coins, int amount) &#123;    int[] dp = new int[amount+1];    dp[0] = 0;    for (int i = 1; i &lt; amount + 1; i++) &#123;        dp[i] = i + 1;    &#125;    for (int i = 1; i &lt; amount + 1; i++) &#123;        for (int coin: coins) &#123;            if (i - coin &lt; 0) continue;            if (dp[i-coin] == i-coin+1) continue;            dp[i] = Math.min(dp[i-coin]+1, dp[i]);        &#125;    &#125;    return dp[amount] == amount + 1 ? -1 : dp[amount]; &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归二叉树</title>
      <link href="/2022/09/05/%E9%80%92%E5%BD%92%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2022/09/05/%E9%80%92%E5%BD%92%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前-x2F-中-x2F-后序遍历"><a href="#前-x2F-中-x2F-后序遍历" class="headerlink" title="前&#x2F;中&#x2F;后序遍历"></a>前&#x2F;中&#x2F;后序遍历</h2><p><strong>递归</strong></p><ul><li>只要是递归调用, 就存在前序和后序<ul><li>前序指递归前</li><li>后序指递归后</li></ul></li><li>由于二叉树需要先后递归左右子树, 在两次递归之间称为中序</li></ul><pre><code class="java">private List&lt;Integer&gt; track = new ArrayList&lt;&gt;();private void traverse(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    track.add(root.val);    traverse(root.left);      // 中序遍历 track.add(root.val);    traverse(root.right);      // 后序遍历 track.add(root.val);&#125;public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;    traverse(root);    return track;&#125;</code></pre><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><p><strong>最大深度</strong>: 根节点到「最远」叶子节点的最长路径上的节点个数</p><p><strong>思路</strong>: 遍历所有「叶子节点」, 比较「根节点」到所有「叶子节点」的长度, 取最大的一个</p><pre><code class="java">private int maxDepth = 0;private void traverse(TreeNode root, int depth) &#123;    if (root == null) &#123;        return;    &#125;    if (root.left == null &amp;&amp; root.right == null) &#123;        maxDepth = Math.max(maxDepth, depth);    &#125;    traverse(root.left, depth+1);    traverse(root.right, depth+1);&#125;public int maxDepth(TreeNode root) &#123;    traverse(root, 1);    return maxDepth;&#125;</code></pre><h2 id="利用后序位置搜集子树的信息"><a href="#利用后序位置搜集子树的信息" class="headerlink" title="利用后序位置搜集子树的信息"></a>利用后序位置搜集子树的信息</h2><h3 id="统计二叉树节点个数"><a href="#统计二叉树节点个数" class="headerlink" title="统计二叉树节点个数"></a>统计二叉树节点个数</h3><p>由于后序是在递归之后发生, 可以理解后序是站在根节点观察左右子树, 在这个位置可以拿到左右子树的遍历结果.</p><p>当前根节点对应的子树包含的节点个数 &#x3D; 「左子树」的节点个数 + 「右子树」的节点个数 + 1「根节点」</p><pre><code class="java">private int count = 0;private int traverse(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    int left = traverse(root.left);    int right = traverse(root.right);    // 「左子树」的节点个数 + 「右子树」的节点个数 + 1「根节点」    count = Math.max(left+right+1, count);    return left+right+1;&#125;public int countNodeOfBinaryTree(TreeNode root) &#123;    traverse(root);    return count;&#125;</code></pre><h3 id="二叉树的最长直径"><a href="#二叉树的最长直径" class="headerlink" title="二叉树的最长直径"></a>二叉树的最长直径</h3><p>「当前子树的最长直径」&#x3D; 其「左子树」的深度 + 其「右子树」的深度</p><pre><code class="java">private int diameter = 0;private int traverse(TreeNode root) &#123;    if (root == null) &#123;          return 0;    &#125;    int left = traverse(root.left);    int right = traverse(root.right);      // 「左子树」的深度 + 其「右子树」的深度    diameter = Math.max(left+right, diameter);    return Math.max(left, right) + 1;&#125;public int diameterOfBinaryTree(TreeNode root) &#123;    traverse(root);    return diameter;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组集合技巧合集</title>
      <link href="/2022/09/05/Java%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/"/>
      <url>/2022/09/05/Java%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88%E6%8A%80%E5%B7%A7%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><p><strong>Arrays</strong></p><ul><li>Arrays 工具类中封装了大量的排序算法, 对于升序排序, 直接使用 Arrays.sort 即可.</li><li>如果想对数组类进行逆序排序&#x2F;自定义comparator排序<ul><li>包装类<ul><li><code>Arrays.sort(array, Arrays.sort(nums, (a,b)-&gt;&#123;return b-a;&#125;);)</code></li></ul></li><li>基本类型<ul><li><code>int[] sorted = Arrays.stream(nums).boxed().sorted((a,b)-&gt;&#123;return b-a;&#125;).mapToInt(a-&gt;a).toArray();</code></li></ul></li></ul></li></ul><h2 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h2><p><strong>基本类型数组-&gt;包装类数组</strong></p><ul><li><code>Integer[] sorted = Arrays.stream(nums).boxed().toArray(Integer[]::new);</code></li></ul><p><strong>基本类型数组-&gt;包装类集合</strong></p><ul><li><code>List&lt;Integer&gt; array = Arrays.stream(nums).boxed().collect(Collectors.toList());</code></li></ul><h2 id="集合排序"><a href="#集合排序" class="headerlink" title="集合排序"></a>集合排序</h2><p><strong>Collections</strong></p><ul><li><code>Collections.sort(array, (a,b)-&gt;&#123;return b-a;&#125;);</code></li></ul><h2 id="集合转换"><a href="#集合转换" class="headerlink" title="集合转换"></a>集合转换</h2><p><strong>包装类集合-&gt;包装类数组</strong></p><ul><li><code>Integer[] nums = array.stream().toArray(Integer[]::new);</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组双指针</title>
      <link href="/2022/09/02/%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2022/09/02/%E6%95%B0%E7%BB%84%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p><strong>排序</strong></p><ul><li>使数组成为有序数组</li></ul><p><strong>左右指针</strong></p><ul><li>左右指针分别指向数组第一个元素和数组最后一个元素<ul><li><code>num[left]+num[right]&gt;target:right--;</code></li><li><code>num[left]+num[right]&lt;target:left++;</code></li></ul></li></ul><pre><code class="java">public int[] twoSum(int[] numbers, int target) &#123;    int left = 0;    int right = numbers.length - 1;    while (left &lt; right) &#123;      int p = numbers[left] + numbers[right];      if (p == target) &#123;        return new int[]&#123;left+1, right+1&#125;;      &#125; else if (p &gt; target) &#123;        right--;      &#125; else &#123;        left++;      &#125;    &#125;    return null;&#125;</code></pre><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><p><strong>two sum 改造</strong></p><ul><li>增加一个搜索范围, lo, hi</li><li>成功找到一组后, lo 从下一个不同的地方开始</li></ul><pre><code class="java">public List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int lo, int hi, int target) &#123;    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    int left = lo;    int right = hi;    while (left &lt; right) &#123;        int nleft = nums[left];        int nright = nums[right];        int p = nleft + nright;        if (p == target) &#123;            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(Arrays.asList(nleft, nright, nums[lo-1]));            result.add(tmp);            while (nums[left] == nleft &amp;&amp; left &lt; right) &#123;              left++;            &#125;        &#125; else if (p &gt; target) &#123;            right--;        &#125; else &#123;            left++;        &#125;    &#125;    return result;&#125;</code></pre><p><strong>总体思路</strong></p><ul><li><p>对数组排序</p></li><li><p>外层循环遍历数组, i&#x3D;[0, length-3]</p></li><li><p><code>twoSum(numbers, i+1, length-1, target-nums[i])</code></p><ul><li>如果返回值为 null, 外层继续遍历</li><li>如果返回值不为 null, 加入结果集, 继续遍历</li></ul></li></ul><pre><code class="java">public List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int lo, int hi, int target) &#123;    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    int left = lo;    int right = hi;    while (left &lt; right) &#123;        int nleft = nums[left];        int nright = nums[right];        int p = nleft + nright;        if (p == target) &#123;            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(Arrays.asList(nleft, nright, nums[lo-1]));            result.add(tmp);            while (nums[left] == nleft &amp;&amp; left &lt; right) &#123;              left++;            &#125;        &#125; else if (p &gt; target) &#123;            right--;        &#125; else &#123;            left++;        &#125;    &#125;    return result;&#125;public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    Arrays.sort(nums);    for (int i = 0; i &lt; nums.length-2; i++) &#123;        int num = nums[i];        List&lt;List&lt;Integer&gt;&gt; twoSumResult = twoSum(nums, i+1, nums.length-1, 0-num);        if (!twoSumResult.isEmpty()) &#123;            result.addAll(twoSumResult);            while (i+1 &lt; nums.length-2 &amp;&amp; num == nums[i+1]) &#123;              i++;            &#125;        &#125;    &#125;    return result;&#125;</code></pre><h2 id="原地操作数组"><a href="#原地操作数组" class="headerlink" title="原地操作数组"></a>原地操作数组</h2><h3 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h3><ul><li>双指针, lo 指向待写入的下标, hi 指向写入值对应的下标</li></ul><pre><code class="java">public int removeElement(int[] nums, int val) &#123;    int lo = 0;    int hi = 0;    while (hi &lt; nums.length) &#123;      if (nums[hi] != val) &#123;        nums[lo] = nums[hi];        lo++;      &#125;      hi++;    &#125;    return lo;&#125;</code></pre><h3 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h3><ul><li>移除值为 0 的元素, 然后将 <code>[lo,nums.length-1]</code> 都置为 0</li></ul><pre><code class="java">public void moveZeroes(int[] nums) &#123;    int lo = 0;    int hi = 0;    while (hi &lt; nums.length) &#123;      if (nums[hi] != 0) &#123;        nums[lo] = nums[hi];        lo++;      &#125;      hi++;    &#125;    for (int i = lo; i &lt; nums.length; i++) &#123;      nums[i] = 0;    &#125;&#125;</code></pre><h3 id="删除数组当中的重复项"><a href="#删除数组当中的重复项" class="headerlink" title="删除数组当中的重复项"></a>删除数组当中的重复项</h3><ul><li>数组是否为有序? <ul><li>无序先排序</li><li>有序, lo 指向待写入的下标(待写入的下标为被比较值下标+1), hi 指向待写入的值</li></ul></li></ul><pre><code class="java">public int removeDuplicates(int[] nums) &#123;    int lo = 0;    int hi = lo + 1;    while (hi &lt; nums.length) &#123;      // nums[lo]-&gt;被比较值      if (nums[hi] != nums[lo]) &#123;        // 指向待写入的下标        lo++;        nums[lo] = nums[hi];      &#125;      hi++;    &#125;    return lo+1;&#125;</code></pre><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p><strong>回文子串的定义</strong></p><ul><li>回文子串有两种, 奇数长度 or 偶数长度<ul><li>奇数长度, 双指针从同一个中点像外扩散, 直到两个指针指向的值不相等</li><li>偶数长度, 双指针从相邻的中点像外扩散, 直到两个指针指向的值不相等</li></ul></li><li>由于最长回文子串的中点有可能是原始字符串中的任意一个元素, 所以外层需要遍历 s 的每一个字符</li></ul><p><strong>思路</strong>: 遍历原始字符串中每个元素, 尝试以当前元素(奇偶情况)作为回文子串的中点并向外扩散</p><pre><code class="java">private String longest(String s, int i, int j) &#123;    int len = s.length();    while (i &gt;= 0 &amp;&amp; j &lt; len &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;        i--;        j++;    &#125;    return s.substring(i+1, j);&#125;public String longestPalindrome(String s) &#123;    String max = &quot;&quot;;    for (int i = 0; i &lt; s.length(); i++) &#123;        String result1 = longest(s, i, i);        if (max.length() &lt; result1.length()) &#123;            max = result1;        &#125;        if (i+1 &lt; s.length()) &#123;            String result2 = longest(s, i, i+1);            if (max.length() &lt; result2.length()) &#123;                max = result2;            &#125;        &#125;    &#125;    return max;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表双指针</title>
      <link href="/2022/08/10/%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2022/08/10/%E9%93%BE%E8%A1%A8%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="链表成环"><a href="#链表成环" class="headerlink" title="链表成环"></a>链表成环</h2><h3 id="判断链表成环"><a href="#判断链表成环" class="headerlink" title="判断链表成环"></a>判断链表成环</h3><p><strong>dummy 头节点</strong></p><ul><li>使用 <strong>dummy</strong> 头节点避免空指针</li></ul><p><strong>快慢指针</strong></p><ul><li>快指针走两步, 慢指针走一步, 如果快指针走到末尾节点仍未和慢指针相遇, 则链表无反, 反之, 有环</li></ul><pre><code class="java">public boolean hasCycle(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next了;.next;      slow = slow.next;      if (fast == slow) &#123;        return true;      &#125;    &#125;    return false;&#125;</code></pre><h2 id="找到链表中点"><a href="#找到链表中点" class="headerlink" title="找到链表中点"></a>找到链表中点</h2><p>典型快慢指针, 判断链表成环类似</p><p><strong>dummy 头节点</strong></p><ul><li>使用 <strong>dummy</strong> 头节点避免空指针</li></ul><p><strong>快慢指针(终止条件)</strong></p><ul><li>if fast !&#x3D; null &amp;&amp; fast.next !&#x3D; null, 快指针走两步, 慢指针走一步, if fast.next &#x3D;&#x3D; null: return slow;</li></ul><blockquote><p>长度为奇数</p><p>1-&gt;2(slow)-&gt;3-&gt;null(fast)</p><p>长度为偶数</p><p>1-&gt;2(slow)-&gt;3-&gt;4(fast)-&gt;null</p></blockquote><p><strong>举一反三</strong></p><ul><li>上述终止条件对应偶数长度时, 返回的是靠前的中间节点, 如何返回靠后的?<ul><li><code>return fast != null ? slow.next ? slow;</code></li></ul></li></ul><pre><code class="java">public ListNode middleNode(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next.next;      slow = slow.next;    &#125;    return fast != null ? slow.next : slow;&#125;</code></pre><h3 id="返回环的起点"><a href="#返回环的起点" class="headerlink" title="返回环的起点"></a>返回环的起点</h3><p><img src="./image-20220903201209897.png"></p><p>思路: 快慢指针相遇之后, 将慢指针重新指向头节点, 两个指针步长一致, 再次相遇时正好指向环的起点.</p><pre><code class="java">public ListNode detectCycle(ListNode head) &#123;    ListNode dummy = new ListNode();    dummy.next = head;    ListNode fast = dummy;    ListNode slow = dummy;    while (fast != null &amp;&amp; fast.next != null) &#123;      fast = fast.next.next;      slow = slow.next;      if (fast == slow) &#123;        slow = dummy;        int index = -1;        while (fast != null &amp;&amp; fast != slow) &#123;          fast = fast.next;          slow = slow.next;        &#125;        return slow;      &#125;    &#125;    return null;&#125;</code></pre><h2 id="删除倒数第-k-个节点"><a href="#删除倒数第-k-个节点" class="headerlink" title="删除倒数第 k 个节点"></a>删除倒数第 k 个节点</h2><p><strong>删除节点</strong></p><ul><li>例如如下链表 1-&gt;2-&gt;3, 我们如果要删除节点 2, 那么就需要用指针指向节点 2 的上一个节点, 执行 p.next &#x3D; p.next.next 即可.</li></ul><p><strong>dummy节点</strong></p><blockquote><p>dummy-&gt;head-&gt;…</p></blockquote><ul><li>如果我们要删除头节点, 那么我们指针如何指向头节点的上一个节点, 所以需要一个 dummy 节点</li></ul><p><strong>快慢指针</strong></p><blockquote><p>为了定位倒数 k+1 个节点</p><p>dummy-&gt;1-&gt;2-&gt;3(slow)-&gt;4-&gt;5-&gt;6-&gt;null(fast)</p></blockquote><p>当 slow 和 fast 之间始终间隔 k 个节点时, 如果 fast 节点遍历到 null, 那么 slow 节点正好指向倒数第 k+1 个节点</p><pre><code class="java"> public ListNode removeNthFromEnd(ListNode head, int n) &#123;     ListNode dummy = new ListNode();     dummy.next = head;     ListNode fast = head;     ListNode slow = dummy;     // 与 slow 间隔 k 个节点     for (int i = 0; i &lt; n; i++) &#123;       fast = fast.next;     &#125;     while (fast != null) &#123;       slow = slow.next;       fast = fast.next;     &#125;     slow.next = slow.next.next;     return dummy.next; &#125;</code></pre><h2 id="两链表相交节点"><a href="#两链表相交节点" class="headerlink" title="两链表相交节点"></a>两链表相交节点</h2><p>原始两条链表如下</p><p>a1-&gt;a2-&gt;b1-&gt;b2</p><p>c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3</p><p>将链表1和链表2拼接起来, 形成两条长度一样的链表, 可以发现在遍历完之前 b1 节点重合了</p><p>a1-&gt;a2-&gt;b1-&gt;b2-&gt;null-&gt;c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3-&gt;null</p><p>c1-&gt;c2–&gt;d1-&gt;d2-&gt;b1-&gt;d3-&gt;null-&gt;a1-&gt;a2-&gt;b1-&gt;b2-&gt;null</p><p>解题的关键是将链表1和链表2拼接起来, 判断的条件是如果在到达最后的 null 节点之前重合了, 那么节点相交</p><pre><code class="java">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;    ListNode p1 = headA;    ListNode p2 = headB;    while (p1 != p2) &#123;      if (p1 == null) &#123;        p1 = headB;      &#125; else &#123;        p1 = p1.next;      &#125;      if (p2 == null) &#123;        p2 = headA;      &#125; else &#123;        p2 = p2.next;      &#125;    &#125;    return p1;&#125;</code></pre><h2 id="合并链表"><a href="#合并链表" class="headerlink" title="合并链表"></a>合并链表</h2><h3 id="合并两个链表"><a href="#合并两个链表" class="headerlink" title="合并两个链表"></a>合并两个链表</h3><p><strong>dummy 节点</strong></p><ul><li>使用 dummy 节点保存新链表头指针的引用</li></ul><pre><code class="java">public ListNode mergeTwoLists(ListNode list1, ListNode list2) &#123;    ListNode p1 = list1;    ListNode p2 = list2;    ListNode dummy = new ListNode();    ListNode p = dummy;    while (p1 != null &amp;&amp; p2 != null) &#123;      if (p1.val &gt; p2.val) &#123;        p.next = p2;        p2 = p2.next;      &#125; else &#123;        p.next = p1;        p1 = p1.next;      &#125;      p = p.next;    &#125;    if (p1 != null) &#123;      p.next = p1;    &#125;    if (p2 != null) &#123;      p.next = p2;    &#125;    return dummy.next;&#125;</code></pre><h3 id="合并-k-个链表"><a href="#合并-k-个链表" class="headerlink" title="合并 k 个链表"></a>合并 k 个链表</h3><p><strong>优先级队列</strong></p><ul><li>使用 PriorityQueue 保存不同链表的头节点, 每次从里面取出一个 val 最小的添加到新链表中</li></ul><pre><code class="java">PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((ListNode ln1, ListNode ln2)-&gt;&#123;return ln1.val - ln2.val;&#125;);</code></pre><pre><code class="java">public ListNode mergeKLists(ListNode[] lists) &#123;    PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;((ListNode ln1, ListNode ln2)-&gt;&#123;return ln1.val - ln2.val;&#125;);    ListNode dummy = new ListNode();    ListNode p = dummy;    for (ListNode ln: lists) &#123;      if (ln != null) &#123;        pq.offer(ln);      &#125;    &#125;    while (!pq.isEmpty()) &#123;      ListNode n1 = pq.poll();      p.next = n1;      p = p.next;      if (n1.next != null) &#123;        pq.offer(n1.next);      &#125;    &#125;    return dummy.next;&#125;</code></pre><h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h2><p><strong>链表拆分, 注意切断原有联系</strong></p><blockquote><p>原链表: 1-&gt;5-&gt;3-&gt;4-&gt;6</p><p>新链表(smaller): 1-&gt;3-&gt;4(-&gt;6)</p><p>注意节点 4 后面还连着节点 6, 必须把其置为 null.</p></blockquote><pre><code class="java">public ListNode partition(ListNode head, int x) &#123;    ListNode smaller = new ListNode();    ListNode bigger = new ListNode();    ListNode p1 = smaller;    ListNode p2 = bigger;    ListNode p = head;    while (p != null) &#123;      if (p.val &lt; x) &#123;        p1.next = p;        p = p.next;        p1 = p1.next;      &#125; else &#123;        p2.next = p;        p = p.next;        p2 = p2.next;      &#125;    &#125;    // 切断原有联系    p2.next = null;    p1.next = bigger.next;    return smaller.next;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
