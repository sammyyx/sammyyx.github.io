[{"id":0,"href":"/docs/tech/network/tcp/","title":"TCP 协议常见问题","section":"网络","content":" TCP 协议常见问题 # 三次握手 # 基本原理\n注意上图 ACK 和 ack 的区别, ACK/SYN/FIN 都是标志位, 其值只有 1 或 0, ack 代表确认号, 代表希望下一次收到的 seq 为 ack.\n三次握手的目的: 建立可靠的全双工通信机制\n为什么需要三次握手:\n(1) 防止重复连接, 在网络状况比较差的情况下, 发送方可能发了多次建立连接的请求, 如果只有两次请求, server 只能选择接收或者是拒绝, 但 server 区分不了这是正常的请求还是重发的请求, 所以重发的请求会导致大量无效连接的建立.\n如果是三次握手, 客户端可以根据接收到的消息, 判断当前连接是否为历史连接, 如果判断为历史连接, 就会发送 RST 报文给服务端终止连接. 如果判断不是历史连接, 就是执行第三次握手.\n(2) 同步初始化序列号, 如果是两次握手就无法对序列号进行确认了.\n序列号的作用就是防止数据包重复发送, 以及有效的解决数据接收时顺序颠倒的问题.\n四次挥手 # 连接建立双方都可以主动断开连接. 由于每个方向都有一对 FIN 和 ACK, 故称为 4 次握手.\nFIN 仅仅代表发起方不再发送消息了, 但是还能接收消息. 以上图为例, server 收到 client 的 FIN 后, 由于服务端可能还有数据需要处理和发送, 因此先回了一个 ACK,\n客户端为什么需要等 2MSL: 确保服务端接收到了 ACK, 如果服务端在一个 MSL 未接收到, 客户端会重发 FIN, 客户端会再次发 ACK 进行确认. 如果没有这个 2MSL, 服务端重发的 FIN 客户端无法接收到, 导致服务端侧的连接无法关闭.\n滑动窗口 # 由于 TCP 是一个全双工协议 (可以同时接收和发送消息), 滑动窗口解决的是流量控制问题, 如果接收端和发送端对数据包处理速度不同, 如何让双方达成一致.\n一句话介绍滑动窗口协议: 由于TCP是全双工协议,发送方和接收方都可以发送和接收消息,所以它们各有一个发送窗口和接收窗口,发送窗口中保存着发送但未收到ACK的数据以及待发送的数据, 当收到来自接收方的 ACK 后窗口会进行相应的收缩和移动, 接收窗口代表允许接收的数据长度.\n接收窗口和发送窗口存储在系统缓存中,会随着协议运行自动调整(操作系统), 当我们的应用程序没有足够快地读取字节时, 缓存区中的可用空间就会缩小.\n比如缓存中存储了 150 个字节, 应用服务从缓存中只读取了 50 个字节, 那么剩余 100 个字节还在缓存区中, 假设缓存区总空间为 300, 此时缓存区可用空间只有 200, 那么对应接收窗口的大小也相应的调整到 200.\n发送窗口 # 可用窗口大小 = SND.UNA + SND.WND - SND.NXT\n接收窗口 # 拥塞控制 # 一句话: 发送方维护一个拥塞窗口(cwnd)用于完成拥塞控制. 原则: 只有网络没有出现拥塞, 拥塞窗口可以增大一点; 当网路中出现拥塞后, 就必须缩小拥塞窗口. 发送方判断网络拥塞的依据就是是否发生了超时.\n慢启动 # 一句话: 由小到大(指数递增)慢慢增加拥塞窗口.\n拥塞避免 # 算法: 每经过一个 RTT, 对 cwnd 进行加一.\n遇到拥塞时, ssthresh = cwnd / 2. cwnd 重新从 1 开始.\n一句话:\n引入慢开始门限, 分段使用不同算法控制cwnd的增长 当 cwnd \u0026lt; ssthresh 时, 使用慢开始算法\n当 cwnd = ssthresh 时, 使用拥塞避免算法\n当 cwnd \u0026gt; ssthresh 时, 使用慢开始/拥塞避免算法\n快重传 # 不要等待自己发送消息的时候再去捎带 ACK, 而是要立即发送确认, 即使收到失序的报文段也要立即发出对已收到报文段的重复确认. 发送方只要一连收到3个重复确认, 立即进行重传. 快恢复 # 快恢复门限由 ssthresh 开始.\n"},{"id":1,"href":"/docs/alogrithm/array/%E5%8F%8C%E6%8C%87%E9%92%88/","title":"双指针","section":"数组","content":" 双指针 # 两数之和 # 排序\n使数组成为有序数组 左右指针\n左右指针分别指向数组第一个元素和数组最后一个元素 num[left]+num[right]\u0026gt;target:right--; num[left]+num[right]\u0026lt;target:left++; public int[] twoSum(int[] numbers, int target) { int left = 0; int right = numbers.length - 1; while (left \u0026lt; right) { int p = numbers[left] + numbers[right]; if (p == target) { return new int[]{left+1, right+1}; } else if (p \u0026gt; target) { right--; } else { left++; } } return null; } 三数之和 # "},{"id":2,"href":"/docs/alogrithm/list/linked-list-cycle/","title":"双指针","section":"链表","content":" 双指针 # 链表成环 # 判断链表成环 # dummy 头节点\n使用 dummy 头节点避免空指针 快慢指针\n快指针走两步, 慢指针走一步, 如果快指针走到末尾节点仍未和慢指针相遇, 则链表无反, 反之, 有环 public boolean hasCycle(ListNode head) { ListNode dummy = new ListNode(); dummy.next = head; ListNode fast = dummy; ListNode slow = dummy; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next了;.next; slow = slow.next; if (fast == slow) { return true; } } return false; } 找到链表中点 # 典型快慢指针, 判断链表成环类似\ndummy 头节点\n使用 dummy 头节点避免空指针 快慢指针(终止条件)\nif fast != null \u0026amp;\u0026amp; fast.next != null, 快指针走两步, 慢指针走一步, if fast.next == null: return slow; 长度为奇数\n1-\u0026gt;2(slow)-\u0026gt;3-\u0026gt;null(fast)\n长度为偶数\n1-\u0026gt;2(slow)-\u0026gt;3-\u0026gt;4(fast)-\u0026gt;null\n举一反三\n上述终止条件对应偶数长度时, 返回的是靠前的中间节点, 如何返回靠后的? return fast != null ? slow.next ? slow; public ListNode middleNode(ListNode head) { ListNode dummy = new ListNode(); dummy.next = head; ListNode fast = dummy; ListNode slow = dummy; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; } return fast != null ? slow.next : slow; } 返回环的起点 # 思路: 快慢指针相遇之后, 将慢指针重新指向头节点, 两个指针步长一致, 再次相遇时正好指向环的起点.\npublic ListNode detectCycle(ListNode head) { ListNode dummy = new ListNode(); dummy.next = head; ListNode fast = dummy; ListNode slow = dummy; while (fast != null \u0026amp;\u0026amp; fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { slow = dummy; int index = -1; while (fast != null \u0026amp;\u0026amp; fast != slow) { fast = fast.next; slow = slow.next; } return slow; } } return null; } 删除倒数第 k 个节点 # 删除节点\n例如如下链表 1-\u0026gt;2-\u0026gt;3, 我们如果要删除节点 2, 那么就需要用指针指向节点 2 的上一个节点, 执行 p.next = p.next.next 即可. dummy节点\ndummy-\u0026gt;head-\u0026gt;\u0026hellip;\n如果我们要删除头节点, 那么我们指针如何指向头节点的上一个节点, 所以需要一个 dummy 节点 快慢指针\n为了定位倒数 k+1 个节点\ndummy-\u0026gt;1-\u0026gt;2-\u0026gt;3(slow)-\u0026gt;4-\u0026gt;5-\u0026gt;6-\u0026gt;null(fast)\n当 slow 和 fast 之间始终间隔 k 个节点时, 如果 fast 节点遍历到 null, 那么 slow 节点正好指向倒数第 k+1 个节点\npublic ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(); dummy.next = head; ListNode fast = head; ListNode slow = dummy; // 与 slow 间隔 k 个节点 for (int i = 0; i \u0026lt; n; i++) { fast = fast.next; } while (fast != null) { slow = slow.next; fast = fast.next; } slow.next = slow.next.next; return dummy.next; } 两链表相交节点 # 原始两条链表如下\na1-\u0026gt;a2-\u0026gt;b1-\u0026gt;b2\nc1-\u0026gt;c2\u0026ndash;\u0026gt;d1-\u0026gt;d2-\u0026gt;b1-\u0026gt;d3\n将链表1和链表2拼接起来, 形成两条长度一样的链表, 可以发现在遍历完之前 b1 节点重合了\na1-\u0026gt;a2-\u0026gt;b1-\u0026gt;b2-\u0026gt;null-\u0026gt;c1-\u0026gt;c2\u0026ndash;\u0026gt;d1-\u0026gt;d2-\u0026gt;b1-\u0026gt;d3-\u0026gt;null\nc1-\u0026gt;c2\u0026ndash;\u0026gt;d1-\u0026gt;d2-\u0026gt;b1-\u0026gt;d3-\u0026gt;null-\u0026gt;a1-\u0026gt;a2-\u0026gt;b1-\u0026gt;b2-\u0026gt;null\n解题的关键是将链表1和链表2拼接起来, 判断的条件是如果在到达最后的 null 节点之前重合了, 那么节点相交\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode p1 = headA; ListNode p2 = headB; while (p1 != p2) { if (p1 == null) { p1 = headB; } else { p1 = p1.next; } if (p2 == null) { p2 = headA; } else { p2 = p2.next; } } return p1; } 合并链表 # 合并两个链表 # dummy 节点\n使用 dummy 节点保存新链表头指针的引用 public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode p1 = list1; ListNode p2 = list2; ListNode dummy = new ListNode(); ListNode p = dummy; while (p1 != null \u0026amp;\u0026amp; p2 != null) { if (p1.val \u0026gt; p2.val) { p.next = p2; p2 = p2.next; } else { p.next = p1; p1 = p1.next; } p = p.next; } if (p1 != null) { p.next = p1; } if (p2 != null) { p.next = p2; } return dummy.next; } 合并 k 个链表 # 优先级队列\n使用 PriorityQueue 保存不同链表的头节点, 每次从里面取出一个 val 最小的添加到新链表中 PriorityQueue\u0026lt;ListNode\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((ListNode ln1, ListNode ln2)-\u0026gt;{return ln1.val - ln2.val;}); public ListNode mergeKLists(ListNode[] lists) { PriorityQueue\u0026lt;ListNode\u0026gt; pq = new PriorityQueue\u0026lt;\u0026gt;((ListNode ln1, ListNode ln2)-\u0026gt;{return ln1.val - ln2.val;}); ListNode dummy = new ListNode(); ListNode p = dummy; for (ListNode ln: lists) { if (ln != null) { pq.offer(ln); } } while (!pq.isEmpty()) { ListNode n1 = pq.poll(); p.next = n1; p = p.next; if (n1.next != null) { pq.offer(n1.next); } } return dummy.next; } 分隔链表 # 链表拆分, 注意切断原有联系\n原链表: 1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;6\n新链表(smaller): 1-\u0026gt;3-\u0026gt;4(-\u0026gt;6)\n注意节点 4 后面还连着节点 6, 必须把其置为 null.\npublic ListNode partition(ListNode head, int x) { ListNode smaller = new ListNode(); ListNode bigger = new ListNode(); ListNode p1 = smaller; ListNode p2 = bigger; ListNode p = head; while (p != null) { if (p.val \u0026lt; x) { p1.next = p; p = p.next; p1 = p1.next; } else { p2.next = p; p = p.next; p2 = p2.next; } } // 切断原有联系 p2.next = null; p1.next = bigger.next; return smaller.next; } "},{"id":3,"href":"/docs/alogrithm/array/java-%E6%8E%92%E5%BA%8F%E6%8A%80%E5%B7%A7/","title":"Java 排序技巧","section":"数组","content":" Java 技巧 # 数组排序 # Arrays\nArrays 工具类中封装了大量的排序算法, 对于升序排序, 直接使用 Arrays.sort 即可. 如果想对数组类进行逆序排序/自定义comparator排序 包装类 Arrays.sort(array, Arrays.sort(nums, (a,b)-\u0026gt;{return b-a;});) 基本类型 int[] sorted = Arrays.stream(nums).boxed().sorted((a,b)-\u0026gt;{return b-a;}).mapToInt(a-\u0026gt;a).toArray(); 数组转换 # 基本类型数组-\u0026gt;包装类数组\nInteger[] sorted = Arrays.stream(nums).boxed().toArray(Integer[]::new); 基本类型数组-\u0026gt;包装类集合\nList\u0026lt;Integer\u0026gt; array = Arrays.stream(nums).boxed().collect(Collectors.toList()); 集合排序 # Collections\nCollections.sort(array, (a,b)-\u0026gt;{return b-a;}); 集合转换 # 包装类集合-\u0026gt;包装类数组\nInteger[] nums = array.stream().toArray(Integer[]::new); "}]