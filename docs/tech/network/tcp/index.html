<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="TCP 协议常见问题 # 三次握手 # 基本原理
注意上图 ACK 和 ack 的区别, ACK/SYN/FIN 都是标志位, 其值只有 1 或 0, ack 代表确认号, 代表希望下一次收到的 seq 为 ack.
三次握手的目的: 建立可靠的全双工通信机制
为什么需要三次握手:
(1) 防止重复连接, 在网络状况比较差的情况下, 发送方可能发了多次建立连接的请求, 如果只有两次请求, server 只能选择接收或者是拒绝, 但 server 区分不了这是正常的请求还是重发的请求, 所以重发的请求会导致大量无效连接的建立.
如果是三次握手, 客户端可以根据接收到的消息, 判断当前连接是否为历史连接, 如果判断为历史连接, 就会发送 RST 报文给服务端终止连接. 如果判断不是历史连接, 就是执行第三次握手.
(2) 同步初始化序列号, 如果是两次握手就无法对序列号进行确认了.
序列号的作用就是防止数据包重复发送, 以及有效的解决数据接收时顺序颠倒的问题.
四次挥手 # 连接建立双方都可以主动断开连接. 由于每个方向都有一对 FIN 和 ACK, 故称为 4 次握手.
FIN 仅仅代表发起方不再发送消息了, 但是还能接收消息. 以上图为例, server 收到 client 的 FIN 后, 由于服务端可能还有数据需要处理和发送, 因此先回了一个 ACK,">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="TCP 协议常见问题" />
<meta property="og:description" content="TCP 协议常见问题 # 三次握手 # 基本原理
注意上图 ACK 和 ack 的区别, ACK/SYN/FIN 都是标志位, 其值只有 1 或 0, ack 代表确认号, 代表希望下一次收到的 seq 为 ack.
三次握手的目的: 建立可靠的全双工通信机制
为什么需要三次握手:
(1) 防止重复连接, 在网络状况比较差的情况下, 发送方可能发了多次建立连接的请求, 如果只有两次请求, server 只能选择接收或者是拒绝, 但 server 区分不了这是正常的请求还是重发的请求, 所以重发的请求会导致大量无效连接的建立.
如果是三次握手, 客户端可以根据接收到的消息, 判断当前连接是否为历史连接, 如果判断为历史连接, 就会发送 RST 报文给服务端终止连接. 如果判断不是历史连接, 就是执行第三次握手.
(2) 同步初始化序列号, 如果是两次握手就无法对序列号进行确认了.
序列号的作用就是防止数据包重复发送, 以及有效的解决数据接收时顺序颠倒的问题.
四次挥手 # 连接建立双方都可以主动断开连接. 由于每个方向都有一对 FIN 和 ACK, 故称为 4 次握手.
FIN 仅仅代表发起方不再发送消息了, 但是还能接收消息. 以上图为例, server 收到 client 的 FIN 后, 由于服务端可能还有数据需要处理和发送, 因此先回了一个 ACK," />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://sammyyx.github.io/docs/tech/network/tcp/" /><meta property="article:section" content="docs" />



<title>TCP 协议常见问题 | LEARN</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.c58292d36b18b675680ab9baea2029204537b839ea72f258746ec0f32ce8d6c8.css" integrity="sha256-xYKS02sYtnVoCrm66iApIEU3uDnqcvJYdG7A8yzo1sg=" crossorigin="anonymous">
  <script defer src="/flexsearch.min.js"></script>
  <script defer src="/en.search.min.830ce6b593304c6853cd5deb4210fe026bb1ac64d372c700eb956acdc81a9ee3.js" integrity="sha256-gwzmtZMwTGhTzV3rQhD&#43;AmuxrGTTcscA65VqzcganuM=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>LEARN</span>
  </a>
</h2>


<div class="book-search">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>












  



  
  <ul>
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>刷题笔记</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <span>链表</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/alogrithm/list/linked-list-cycle/" class="">快慢指针</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
      
        <li class="book-section-flat" >
          
  
  

  
    <span>语言&amp;框架</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <span>Java</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>Spring</span>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <span>网络</span>
  

          
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/tech/network/tcp/" class="active">TCP 协议常见问题</a>
  

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>

        </li>
      
    
  </ul>











  
<ul>
  
  <li>
    <a href="/posts/" >
        最近发布
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <strong>TCP 协议常见问题</strong>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#tcp-协议常见问题">TCP 协议常见问题</a>
      <ul>
        <li><a href="#三次握手">三次握手</a></li>
        <li><a href="#四次挥手">四次挥手</a></li>
        <li><a href="#滑动窗口">滑动窗口</a></li>
        <li><a href="#拥塞控制">拥塞控制</a></li>
        <li><a href="#快重传">快重传</a></li>
        <li><a href="#快恢复">快恢复</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown"><h2 id="tcp-协议常见问题">
  TCP 协议常见问题
  <a class="anchor" href="#tcp-%e5%8d%8f%e8%ae%ae%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98">#</a>
</h2>
<h3 id="三次握手">
  三次握手
  <a class="anchor" href="#%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b">#</a>
</h3>
<p><strong>基本原理</strong></p>
<p><img src="image/image-20220827100517131.png" alt="" /></p>
<p>注意上图 ACK 和 ack 的区别, ACK/SYN/FIN 都是标志位, 其值只有 1 或 0, ack 代表确认号, 代表希望下一次收到的 seq 为 ack.</p>
<p>三次握手的目的: <strong>建立可靠的全双工通信机制</strong></p>
<p>为什么需要三次握手:</p>
<p>(1) <strong>防止重复连接</strong>, 在网络状况比较差的情况下, 发送方可能发了多次建立连接的请求, 如果只有两次请求, server 只能选择接收或者是拒绝, 但 server 区分不了这是正常的请求还是重发的请求, 所以重发的请求会导致大量无效连接的建立.</p>
<blockquote>
<p>如果是三次握手, 客户端可以根据接收到的消息, 判断当前连接是否为历史连接, 如果判断为历史连接, 就会发送 RST 报文给服务端终止连接. 如果判断不是历史连接, 就是执行第三次握手.</p>
</blockquote>
<p>(2) <strong>同步初始化序列号</strong>, 如果是两次握手就无法对序列号进行确认了.</p>
<blockquote>
<p>序列号的作用就是防止数据包重复发送, 以及有效的解决数据接收时顺序颠倒的问题.</p>
</blockquote>
<h3 id="四次挥手">
  四次挥手
  <a class="anchor" href="#%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b">#</a>
</h3>
<p><img src="image/image-20220827103412195.png" alt="" /></p>
<p>连接建立双方都可以主动断开连接. 由于每个方向都有一对 FIN 和 ACK, 故称为 4 次握手.</p>
<p>FIN 仅仅代表发起方不再发送消息了, 但是还能接收消息. 以上图为例, server 收到 client 的 FIN 后, 由于服务端可能还有数据需要处理和发送, 因此先回了一个 ACK,</p>
<p>客户端为什么需要等 2MSL: 确保服务端接收到了 ACK, 如果服务端在一个 MSL 未接收到, 客户端会重发 FIN, 客户端会再次发 ACK 进行确认. 如果没有这个 2MSL, 服务端重发的 FIN 客户端无法接收到, 导致服务端侧的连接无法关闭.</p>
<h3 id="滑动窗口">
  滑动窗口
  <a class="anchor" href="#%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3">#</a>
</h3>
<p>由于 TCP 是一个全双工协议 (可以同时接收和发送消息), 滑动窗口解决的是流量控制问题, 如果接收端和发送端对数据包处理速度不同, 如何让双方达成一致.</p>
<p>一句话介绍滑动窗口协议: <strong>由于TCP是全双工协议,发送方和接收方都可以发送和接收消息,所以它们各有一个发送窗口和接收窗口,发送窗口中保存着发送但未收到ACK的数据以及待发送的数据, 当收到来自接收方的 ACK 后窗口会进行相应的收缩和移动, 接收窗口代表允许接收的数据长度.</strong></p>
<p>接收窗口和发送窗口存储在系统缓存中,会随着协议运行自动调整(操作系统), 当我们的应用程序没有足够快地读取字节时, 缓存区中的可用空间就会缩小.</p>
<blockquote>
<p>比如缓存中存储了 150 个字节, 应用服务从缓存中只读取了 50 个字节, 那么剩余 100 个字节还在缓存区中, 假设缓存区总空间为 300, 此时缓存区可用空间只有 200, 那么对应接收窗口的大小也相应的调整到 200.</p>
</blockquote>
<h4 id="发送窗口">
  发送窗口
  <a class="anchor" href="#%e5%8f%91%e9%80%81%e7%aa%97%e5%8f%a3">#</a>
</h4>
<p><img src="image/image-20220827105959833.png" alt="" /></p>
<p><strong>可用窗口大小</strong> = SND.UNA + SND.WND - SND.NXT</p>
<h4 id="接收窗口">
  接收窗口
  <a class="anchor" href="#%e6%8e%a5%e6%94%b6%e7%aa%97%e5%8f%a3">#</a>
</h4>
<p><img src="image/image-20220827110224421.png" alt="" /></p>
<h3 id="拥塞控制">
  拥塞控制
  <a class="anchor" href="#%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6">#</a>
</h3>
<p>一句话: 发送方维护一个拥塞窗口(cwnd)用于完成拥塞控制. 原则: 只有网络没有出现拥塞, 拥塞窗口可以增大一点; 当网路中出现拥塞后, 就必须缩小拥塞窗口. 发送方判断网络拥塞的依据就是是否发生了超时.</p>
<h4 id="慢启动">
  慢启动
  <a class="anchor" href="#%e6%85%a2%e5%90%af%e5%8a%a8">#</a>
</h4>
<p>一句话: 由小到大(指数递增)慢慢增加拥塞窗口.</p>
<h4 id="拥塞避免">
  拥塞避免
  <a class="anchor" href="#%e6%8b%a5%e5%a1%9e%e9%81%bf%e5%85%8d">#</a>
</h4>
<p>算法: 每经过一个 RTT, 对 cwnd 进行加一.</p>
<p>遇到拥塞时, ssthresh  = cwnd / 2. cwnd 重新从 1 开始.</p>
<p>一句话:</p>
<ol>
<li>引入慢开始门限, 分段使用不同算法控制cwnd的增长</li>
</ol>
<p>当 cwnd &lt; ssthresh 时, 使用慢开始算法</p>
<p>当 cwnd = ssthresh 时, 使用拥塞避免算法</p>
<p>当 cwnd &gt; ssthresh 时, 使用慢开始/拥塞避免算法</p>
<h3 id="快重传">
  快重传
  <a class="anchor" href="#%e5%bf%ab%e9%87%8d%e4%bc%a0">#</a>
</h3>
<ol>
<li>不要等待自己发送消息的时候再去捎带 ACK, 而是要立即发送确认, 即使收到失序的报文段也要立即发出对已收到报文段的重复确认.</li>
<li>发送方只要一连收到3个重复确认, 立即进行重传.</li>
</ol>
<h3 id="快恢复">
  快恢复
  <a class="anchor" href="#%e5%bf%ab%e6%81%a2%e5%a4%8d">#</a>
</h3>
<p>快恢复门限由 ssthresh 开始.</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#tcp-协议常见问题">TCP 协议常见问题</a>
      <ul>
        <li><a href="#三次握手">三次握手</a></li>
        <li><a href="#四次挥手">四次挥手</a></li>
        <li><a href="#滑动窗口">滑动窗口</a></li>
        <li><a href="#拥塞控制">拥塞控制</a></li>
        <li><a href="#快重传">快重传</a></li>
        <li><a href="#快恢复">快恢复</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












